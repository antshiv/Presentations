<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LayerNorm: The Complete Story</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reset.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/theme/black.css" id="theme">
    <link rel="stylesheet" href="../reveal.js/plugin/highlight/monokai.css" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
        <script src="https://cdn.tailwindcss.com"></script>

    <style>
        :root {
            --r-main-font: 'Inter', sans-serif;
            --r-heading-font: 'Inter', sans-serif;
            --c-blue: #42a5f5;
            --c-green: #66bb6a;
            --c-orange: #ffa726;
            --c-red: #ef5350;
            --c-purple: #ab47bc;
            --c-gray: #37474f;
            --c-bert: #ff6b6b;
            --c-gpt: #4ecdc4;
            --c-bg: #263238;
            --c-text: #eceff1;
        }
        .reveal { 
            font-family: var(--r-main-font); 
            font-size: 20px;
            background-color: #1a1a1a;
            font-family: 'Inter', sans-serif;
        }
        .reveal h1, .reveal h2, .reveal h3, .reveal h4 { 
            text-transform: none; 
            font-weight: 700; 
            color: var(--c-text); 
        }
        .reveal .highlight { color: var(--c-orange); }
        .reveal .bert-color { color: var(--c-bert); }
        .reveal .gpt-color { color: var(--c-gpt); }
        .reveal .dim { color: #90a4ae; }
        .reveal .smaller { font-size: 0.8em; }
        .reveal .tiny { font-size: 0.7em; }

        /* SVG Styles */
        .viz-svg { 
            width: 100%; 
            height: auto; 
            background-color: var(--c-bg); 
            border-radius: 10px; 
            margin-top: 10px; 
        }
        .svg-text { 
            font-family: var(--r-main-font); 
            fill: white; 
            text-anchor: middle; 
            font-size: 10px; 
        }
        .svg-label { font-size: 11px; font-weight: bold; }
        .svg-desc { font-size: 9px; fill: #ccc; }
        .svg-box { stroke-width: 2px; rx: 5; }
        .svg-arrow { stroke: #eee; stroke-width: 2px; fill: none; marker-end: url(#arrowhead); }
        .svg-dashed-arrow { stroke: #ccc; stroke-width: 2px; fill: none; marker-end: url(#arrowhead); stroke-dasharray: 5 5; }
        .svg-grad-arrow { stroke: var(--c-orange); stroke-width: 3px; fill: none; marker-end: url(#grad-arrowhead); stroke-dasharray: 8 4; }

        /* Layout */
        .two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start; }
        .three-col { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; align-items: center; }
        .two-col .viz-svg { transform: scale(0.85); transform-origin: center center; }

        /* Photo elements */
        .photo-container { display: flex; justify-content: space-around; align-items: center; width: 100%; margin-top: 20px; }
        .photo-card {
            background-color: var(--c-bg);
            border-radius: 15px;
            padding: 15px;
            width: 280px;
            height: 320px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 1px solid #455a64;
        }
        .photo-element {
            width: 240px;
            height: 160px;
            background-image: url('https://images.unsplash.com/photo-1506744038136-46273834b3fb?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80');
            background-size: cover;
            background-position: center;
            border-radius: 8px;
        }
        .slider-controls { width: 240px; }
        .slider-group { margin: 15px 0; }
        .slider-group label { display: block; margin-bottom: 8px; font-weight: bold; font-size: 0.8em; }
        input[type="range"] { width: 100%; }

        /* Chart containers */
        .chart-container { width: 80%; max-width: 500px; margin: 15px auto; }
        .dual-chart-container { display: flex; justify-content: space-around; width: 100%; }
        .chart-half { width: 45%; }
        .stats-box { background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 8px; margin-top: 8px; }
        .stats-box p { margin: 3px 0; font-size: 0.7em; }

        /* Math insight boxes */
        .math-insight { 
            background: rgba(66, 175, 250, 0.1); 
            border: 2px solid var(--c-blue); 
            border-radius: 8px; 
            padding: 15px; 
            margin: 15px 0; 
        }
        .math-insight h4 { color: var(--c-blue); margin-bottom: 8px; }

        /* Timeline */
        .timeline { display: flex; justify-content: space-around; align-items: center; margin: 20px 0; }
        .timeline-item { text-align: center; position: relative; }
        .timeline-year { font-size: 18px; font-weight: bold; color: var(--c-orange); }
        .timeline-model { font-size: 12px; margin-top: 5px; }
        .timeline-line { height: 3px; background: linear-gradient(90deg, var(--c-bert) 0%, var(--c-gpt) 100%); flex-grow: 1; margin: 0 10px; }

        /* Progress indicators */
        .section-progress {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.7em;
            z-index: 1000;
        }
        .formula-box {
            font-size: 72px;
        }
                .label { font-size: 14px; font-weight: 500; fill: #334155; }
        .title { font-size: 20px; font-weight: 700; fill: #0f172a; }
        .sub-label { font-size: 14px; fill: #475569; }
        .small-label { font-size: 10px; fill: #475569; }
        .mono-label { font-family: 'monospace'; font-size: 11px; fill: #1e293b; }
        .exec-label { font-family: 'monospace'; font-size: 11px; font-weight: 500; fill: white; }
        .arrow-path { stroke-width: 2.5; fill: none; }
        .data-path { stroke-dasharray: 6 4; animation: flow 1.5s linear infinite; }
        .gamma-path { stroke-dasharray: 4 4; animation: flow 2s linear infinite; }
        @keyframes flow { from { stroke-dashoffset: 20; } to { stroke-dashoffset: 0; } }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">

            <!-- PART I: THE FOUNDATION -->
            <section data-section="intro">
                <div class="section-progress">Part I: Foundation</div>
                <h1>LayerNorm: The Complete Story</h1>
                <h3>From Mathematical Foundation to Modern AI Revolution</h3>
                <p class="dim">What it is • Why it matters • How it works • When it changed everything</p>
                
                <div style="margin-top: 40px;">
                    <div class="three-col">
                        <div style="text-align: center;">
                            <div style="font-size: 40px; color: var(--c-blue);">🧮</div>
                            <h4>Mathematics</h4>
                            <p class="smaller dim">Internal covariate shift<br>Distribution control</p>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 40px; color: var(--c-orange);">⚡</div>
                            <h4>Revolution</h4>
                            <p class="smaller dim">BERT → GPT-2<br>Architectural breakthrough</p>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 40px; color: var(--c-green);">🔧</div>
                            <h4>Implementation</h4>
                            <p class="smaller dim">HPC optimization<br>Memory & SIMD</p>
                        </div>
                    </div>
                </div>
            </section>

            <section data-section="intro">
                <h2>The Problem: Internal Covariate Shift</h2>
                <p class="smaller">Neural networks work best when inputs have stable statistical properties, but deep networks naturally create chaos.</p>
                
                <div class="chart-container">
                    <canvas id="problemChart" width="600" height="300"></canvas>
                </div>
                
                <div class="math-insight">
                    <h4>🎯 The Core Problem</h4>
                    <p class="smaller">As network weights change during training, the distribution of activations constantly shifts. Later layers can't learn stable patterns when their inputs are chaotic.</p>
                </div>
            </section>

            <section data-section="intro">
                <h2>What Does "Variance" Actually Mean?</h2>
                <p class="smaller">Let's make this concrete. "High variance" means <span class="highlight">unpredictable, chaotic signals</span> that make learning impossible.</p>
                
                <div style="text-align: center;">
                    <svg class="viz-svg" viewBox="0 0 800 300">
                        <defs>
                            <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="0" refY="3" orient="auto">
                                <polygon points="0 0, 8 3, 0 6" fill="#FFF"/>
                            </marker>
                        </defs>
                        <text x="400" y="30" class="svg-label">Signal Behavior: Stable vs Chaotic</text>
                        
                        <!-- Stable signal -->
                        <text x="200" y="60" class="svg-label" fill="var(--c-green)">Low Variance (Good)</text>
                        <path d="M50 150 Q 100 140 150 145 Q 200 150 250 148 Q 300 145 350 147" 
                              stroke="var(--c-green)" stroke-width="3" fill="none"/>
                        <text x="200" y="180" class="svg-desc">Predictable, learnable patterns</text>
                        <text x="200" y="200" class="svg-desc">Network can focus on learning</text>
                        
                        <!-- Chaotic signal -->
                        <text x="600" y="60" class="svg-label" fill="var(--c-red)">High Variance (Bad)</text>
                        <path d="M450 100 Q 500 200 550 80 Q 600 180 650 120 Q 700 90 750 170" 
                              stroke="var(--c-red)" stroke-width="3" fill="none"/>
                        <text x="600" y="180" class="svg-desc">Chaotic, unpredictable jumps</text>
                        <text x="600" y="200" class="svg-desc">Network fights chaos, not learning</text>
                        
                        <!-- Layer progression -->
                        <text x="50" y="270" class="svg-desc">Layer 1</text>
                        <text x="150" y="270" class="svg-desc">Layer 5</text>
                        <text x="250" y="270" class="svg-desc">Layer 10</text>
                        <text x="350" y="270" class="svg-desc">Layer 15</text>
                        
                        <text x="450" y="270" class="svg-desc">Layer 1</text>
                        <text x="550" y="270" class="svg-desc">Layer 5</text>
                        <text x="650" y="270" class="svg-desc">Layer 10</text>
                        <text x="750" y="270" class="svg-desc">Layer 15</text>
                    </svg>
                </div>
            </section>

            <!-- PART II: THE MATH -->
            <section data-section="math">
                <div class="section-progress">Part II: Mathematics</div>
                <h2>LayerNorm: The Photo Editor's Solution</h2>
                <p class="smaller">Think of each layer as a photo editor. High variance = chaotic, flickering input. LayerNorm = giving each editor a clean, neutral canvas first.</p>
                
                <div class="photo-container">
                    <div class="photo-card">
                        <h4>Raw Input (Chaotic)</h4>
                        <div id="bad-photo" class="photo-element"></div>
                        <p class="smaller dim">Flickering brightness, random colors</p>
                    </div>
                    <div style="font-size: 60px; color: var(--c-orange);">→</div>
                    <div class="photo-card">
                        <h4>After LayerNorm</h4>
                        <div id="neutral-photo" class="photo-element"></div>
                        <p class="smaller dim">Clean, neutral canvas</p>
                    </div>
                </div>
            </section>

            <section data-section="math">
                <h2>Where Exactly Is LayerNorm Applied?</h2>
                <p class="smaller">Let's see the complete computation flow and where LayerNorm fits to control variance.</p>
                
                <svg class="viz-svg" viewBox="0 0 1400 500" style="background-color: #1a1a1a;">
                    <defs>
                        <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="0" refY="3" orient="auto">
                            <polygon points="0 0, 8 3, 0 6" fill="#FFF"/>
                        </marker>
                        <marker id="arrowhead-green" markerWidth="8" markerHeight="6" refX="0" refY="3" orient="auto">
                            <polygon points="0 0, 8 3, 0 6" fill="#66bb6a"/>
                        </marker>
                    </defs>
                    
                    <text x="700" y="25" class="svg-label" font-size="16">Complete Transformer Layer: TWO LayerNorm Applications</text>
                    
                    <!-- Input -->
                    <rect x="50" y="100" width="90" height="50" fill="var(--c-blue)" opacity="0.7" stroke="var(--c-blue)" stroke-width="2" rx="8"/>
                    <text x="95" y="120" class="svg-text">Input</text>
                    <text x="95" y="135" class="svg-text">x</text>
                    
                    <!-- Arrow 1 -->
                    <path d="M150 125 L180 125" stroke="#fff" stroke-width="2" marker-end="url(#arrowhead)"/>
                    
                    <!-- LayerNorm 1 (Pre-Attention) -->
                    <rect x="190" y="80" width="100" height="90" fill="var(--c-green)" opacity="0.8" stroke="var(--c-green)" stroke-width="3" rx="10"/>
                    <text x="240" y="100" class="svg-label" fill="#fff" font-size="12">LayerNorm₁</text>
                    <text x="240" y="115" class="svg-text" font-size="11">Pre-Attention</text>
                    <text x="240" y="130" class="svg-text" font-size="10">(x - μ₁) / σ₁</text>
                    <text x="240" y="145" class="svg-text" font-size="10">γ₁ * norm + β₁</text>
                    <text x="240" y="185" class="svg-desc" font-size="9">μ = 0, σ² = 1</text>
                    
                    <!-- Arrow 2 -->
                    <path d="M300 125 L330 125" stroke="var(--c-green)" stroke-width="2" marker-end="url(#arrowhead-green)"/>
                    
                    <!-- Multi-Head Attention -->
                    <rect x="340" y="90" width="100" height="70" fill="var(--c-purple)" opacity="0.7" stroke="var(--c-purple)" stroke-width="2" rx="8"/>
                    <text x="390" y="115" class="svg-text" font-size="11">Multi-Head</text>
                    <text x="390" y="130" class="svg-text" font-size="11">Attention</text>
                    <text x="390" y="145" class="svg-text" font-size="11">Q, K, V</text>
                    
                    <!-- Arrow 3 -->
                    <path d="M450 125 L480 125" stroke="#fff" stroke-width="2" marker-end="url(#arrowhead)"/>
                    
                    <!-- Residual 1 -->
                    <circle cx="500" cy="125" r="15" fill="var(--c-orange)" stroke="var(--c-orange)" stroke-width="2"/>
                    <text x="500" y="130" class="svg-text" font-size="12">+</text>
                    
                    <!-- Residual path 1 -->
                    <path d="M95 170 Q 95 200 390 200 Q 500 200 500 150" stroke="var(--c-blue)" stroke-width="2" fill="none" stroke-dasharray="3,3"/>
                    
                    <!-- Arrow 4 -->
                    <path d="M520 125 L550 125" stroke="#fff" stroke-width="2" marker-end="url(#arrowhead)"/>
                    
                    <!-- LayerNorm 2 (Pre-FFN) -->
                    <rect x="560" y="80" width="100" height="90" fill="var(--c-green)" opacity="0.8" stroke="var(--c-green)" stroke-width="3" rx="10"/>
                    <text x="610" y="100" class="svg-label" fill="#fff" font-size="12">LayerNorm₂</text>
                    <text x="610" y="115" class="svg-text" font-size="11">Pre-FFN</text>
                    <text x="610" y="130" class="svg-text" font-size="10">(y - μ₂) / σ₂</text>
                    <text x="610" y="145" class="svg-text" font-size="10">γ₂ * norm + β₂</text>
                    <text x="610" y="185" class="svg-desc" font-size="9">μ = 0, σ² = 1</text>
                    
                    <!-- Arrow 5 -->
                    <path d="M670 125 L700 125" stroke="var(--c-green)" stroke-width="2" marker-end="url(#arrowhead-green)"/>
                    
                    <!-- Feed-Forward Network -->
                    <rect x="710" y="90" width="100" height="70" fill="var(--c-purple)" opacity="0.7" stroke="var(--c-purple)" stroke-width="2" rx="8"/>
                    <text x="760" y="115" class="svg-text" font-size="11">Feed-Forward</text>
                    <text x="760" y="130" class="svg-text" font-size="11">Network</text>
                    <text x="760" y="145" class="svg-text" font-size="11">W₁, W₂</text>
                    
                    <!-- Arrow 6 -->
                    <path d="M820 125 L850 125" stroke="#fff" stroke-width="2" marker-end="url(#arrowhead)"/>
                    
                    <!-- Residual 2 -->
                    <circle cx="870" cy="125" r="15" fill="var(--c-orange)" stroke="var(--c-orange)" stroke-width="2"/>
                    <text x="870" y="130" class="svg-text" font-size="12">+</text>
                    
                    <!-- Residual path 2 -->
                    <path d="M500 170 Q 500 220 760 220 Q 870 220 870 150" stroke="var(--c-orange)" stroke-width="2" fill="none" stroke-dasharray="3,3"/>
                    
                    <!-- Arrow 7 -->
                    <path d="M890 125 L920 125" stroke="#fff" stroke-width="2" marker-end="url(#arrowhead)"/>
                    
                    <!-- Output -->
                    <rect x="930" y="100" width="90" height="50" fill="var(--c-orange)" opacity="0.7" stroke="var(--c-orange)" stroke-width="2" rx="8"/>
                    <text x="975" y="120" class="svg-text">Output</text>
                    <text x="975" y="135" class="svg-text">z</text>
                    
                    <!-- Step indicators -->
                    <text x="95" y="70" class="svg-desc" fill="var(--c-blue)" font-size="10">Step 1</text>
                    <text x="240" y="70" class="svg-desc" fill="var(--c-green)" font-size="10">Step 2</text>
                    <text x="390" y="70" class="svg-desc" fill="var(--c-purple)" font-size="10">Step 3</text>
                    <text x="500" y="70" class="svg-desc" fill="var(--c-orange)" font-size="10">Step 4</text>
                    <text x="610" y="70" class="svg-desc" fill="var(--c-green)" font-size="10">Step 5</text>
                    <text x="760" y="70" class="svg-desc" fill="var(--c-purple)" font-size="10">Step 6</text>
                    <text x="870" y="70" class="svg-desc" fill="var(--c-orange)" font-size="10">Step 7</text>
                    <text x="975" y="70" class="svg-desc" fill="var(--c-orange)" font-size="10">Step 8</text>
                    
                    <!-- Key insight box -->
                    <rect x="1050" y="60" width="320" height="140" fill="var(--c-green)" opacity="0.1" stroke="var(--c-green)" stroke-width="2" rx="10"/>
                    <text x="1210" y="85" class="svg-label" fill="var(--c-green)">Key Insight</text>
                    <text x="1070" y="105" class="svg-desc" font-size="11">LayerNorm applied TWICE per layer:</text>
                    <text x="1070" y="120" class="svg-desc" font-size="10">• Before Attention (stabilizes Q, K, V)</text>
                    <text x="1070" y="135" class="svg-desc" font-size="10">• Before FFN (stabilizes hidden layer)</text>
                    <text x="1070" y="150" class="svg-desc" font-size="10">• Each has separate γ, β parameters</text>
                    <text x="1070" y="165" class="svg-desc" font-size="10">• Both prevent gradient explosion</text>
                    <text x="1070" y="180" class="svg-desc" font-size="10">• Training becomes much more stable!</text>
                    
                    <!-- Architecture Note -->
                    <text x="700" y="280" class="svg-label" font-size="14" fill="var(--c-green)">Complete Layer Formula:</text>
                    <text x="50" y="310" class="svg-desc" font-size="12">y = x + Attention(LayerNorm₁(x))</text>
                    <text x="50" y="330" class="svg-desc" font-size="12">z = y + FFN(LayerNorm₂(y))</text>
                    
                    <!-- Comparison -->
                    <text x="600" y="370" class="svg-label" font-size="14" fill="var(--c-red)">Without LayerNorm:</text>
                    <text x="50" y="390" class="svg-desc" font-size="11">Activations explode → Gradients vanish/explode → Training fails after few layers</text>
                    
                    <text x="600" y="420" class="svg-label" font-size="14" fill="var(--c-green)">With LayerNorm:</text>
                    <text x="50" y="440" class="svg-desc" font-size="11">Stable activations → Stable gradients → Deep networks train successfully (100+ layers!)</text>
                    
                    <!-- Layer count indicator -->
                    <text x="700" y="460" class="svg-desc" font-size="10" fill="var(--c-blue)">This pattern repeats for every transformer layer (up to 96 layers in GPT-3!)</text>
                </svg>
            </section>

            <section data-section="math">
                <h2>The Math: Forcing Stable Distributions</h2>
                <p class="smaller">LayerNorm ensures every layer receives inputs with mean=0, variance=1, then learns the perfect adjustments.</p>
                
                <div class="dual-chart-container">
                    <div class="chart-half">
                        <h4 style="color: var(--c-red); text-align: center;">Raw Activations (No Normalization)</h4>
                        <canvas id="beforeChart" width="300" height="200"></canvas>
                        <div class="stats-box">
                            <p>μ = 2.3 (shifting)</p>
                            <p>σ² = 5.7 (growing)</p>
                            <p>Training: Unstable</p>
                        </div>
                    </div>
                    <div class="chart-half">
                        <h4 style="color: var(--c-green); text-align: center;">Normalized Activations (LayerNorm Applied)</h4>
                        <canvas id="afterChart" width="300" height="200"></canvas>
                        <div class="stats-box">
                            <p>μ = 0.0 (stable)</p>
                            <p>σ² = 1.0 (controlled)</p>
                            <p>Training: Stable</p>
                        </div>
                    </div>
                </div>
                
                <div class="math-insight fragment">
                    <h4>The Formula</h4>
                    <p style="text-align: center; font-size: 1.2em;">
                        <span class="highlight">output = γ × (x - μ) / √(σ² + ε) + β</span>
                    </p>
                    <p class="smaller">Where μ and σ² are computed per token across embedding dimensions</p>
                </div>
            </section>

            <section data-section="math">
                <h2>Interactive: The γ and β Parameters</h2>
                <p class="smaller">LayerNorm first creates a neutral canvas, then learns the perfect γ (scaling) and β (shifting) for each layer.</p>
                
                <div class="photo-container">
                    <div class="photo-card">
                        <h4>Neutral Canvas</h4>
                        <div class="photo-element"></div>
                    </div>
                    <div class="photo-card slider-controls">
                        <h4>Learnable Parameters</h4>
                        <div class="slider-group">
                            <label for="gamma">Gamma (γ) - <span class="highlight">Contrast</span></label>
                            <input type="range" id="gamma" min="50" max="200" value="100">
                        </div>
                        <div class="slider-group">
                            <label for="beta-brightness">Beta (β) - <span class="highlight">Brightness</span></label>
                            <input type="range" id="beta-brightness" min="50" max="150" value="100">
                        </div>
                        <div class="slider-group">
                            <label for="beta-tint">Beta (β) - <span class="highlight">Color Tint</span></label>
                            <input type="range" id="beta-tint" min="0" max="50" value="0">
                        </div>
                    </div>
                    <div class="photo-card">
                        <h4>Final Output</h4>
                        <div id="stylized-photo" class="photo-element"></div>
                    </div>
                </div>
            </section>
              <section>
                <h2>The Full LayerNorm Formula</h2>
                <p class="smaller">At a high level, the entire operation is captured by this equation:</p>
                <div class="formula-box" style="font-size:72px;">
                    $$ y = \gamma \odot \frac{x - \mu}{\sqrt{\sigma^2 + \epsilon}} + \beta $$
                </div>
                <p class="fragment smaller">Let's break this down piece by piece.</p>
            </section>

            <section>
                <h2>Step 1: The Mean (μ)</h2>
                <p class="smaller">First, we need to find the average value of all the features in our input token.</p>
                <div class="formula-box">
                    $$ \mu = \frac{1}{C} \sum_{i=1}^{C} x_i $$
                </div>
                <div class="explanation">
                    <ul>
                        <li><span class="highlight">$x_i$</span>: This is the i-th feature of our single input token vector.</li>
                        <li><span class="highlight">$C$</span>: This is the total number of features, i.e., the embedding dimension.</li>
                        <li><span class="highlight">$\sum x_i$</span>: We sum up every single feature value in the vector.</li>
                        <li><span class="highlight">$\frac{1}{C} ...$</span>: We divide that sum by the number of features to get the mean.</li>
                    </ul>
                </div>
            </section>

            <section>
                <h2>Step 2: The Variance (σ²)</h2>
                <p class="smaller">Next, we calculate how much our features vary from the mean we just found.</p>
                <div class="formula-box">
                    $$ \sigma^2 = \frac{1}{C} \sum_{i=1}^{C} (x_i - \mu)^2 $$
                </div>
                 <div class="explanation">
                    <ul>
                        <li><span class="highlight">$(x_i - \mu)$</span>: For each feature, we find the difference between its value and the mean.</li>
                        <li><span class="highlight">$(...)^2$</span>: We square that difference. (This ensures the result is positive and penalizes larger deviations more).</li>
                        <li><span class="highlight">$\sum ...$</span>: We sum up all these squared differences.</li>
                        <li><span class="highlight">$\frac{1}{C} ...$</span>: We find the average of the squared differences, which is the variance.</li>
                    </ul>
                </div>
            </section>

            <section>
                <h2>Step 3: Normalization</h2>
                <p class="smaller">Now we use the mean and variance to create a clean, standardized vector.</p>
                <div class="formula-box">
                    $$ \hat{x}_i = \frac{x_i - \mu}{\sqrt{\sigma^2 + \epsilon}} $$
                </div>
                <div class="explanation">
                    <ul>
                        <li><span class="highlight">$x_i - \mu$</span>: We center the data around zero.</li>
                        <li><span class="highlight">$\sqrt{\sigma^2 + \epsilon}$</span>: This is the standard deviation (rstd). The tiny <span class="highlight">$\epsilon$</span> (epsilon) is added for numerical stability to prevent division by zero if the variance is zero.</li>
                        <li>The result, <span class="highlight">$\hat{x}$</span>, is a new vector where the features have a mean of 0 and a variance of 1.</li>
                    </ul>
                </div>
            </section>

            <section>
                <h2>Step 4 & Dimensions</h2>
                <p class="smaller">Finally, we scale and shift the normalized vector using learned parameters.</p>
                <div class="formula-box">
                    $$ y = \gamma \odot \hat{x} + \beta $$
                </div>
                <p class="smaller" style="margin-top: 30px;">Here are the dimensions of each tensor for a <span class="highlight">single token</span> (batch size = 1):</p>
                <table class="dim-table">
                    <thead>
                        <tr><th>Variable</th><th>Symbol</th><th>Dimension</th><th>Description</th></tr>
                    </thead>
                    <tbody>
                        <tr><td>Input</td><td>$x$</td><td>$[C]$</td><td>The 1D vector for one token.</td></tr>
                        <tr><td>Mean</td><td>$\mu$</td><td>Scalar</td><td>A single float, the average of x.</td></tr>
                        <tr><td>Variance</td><td>$\sigma^2$</td><td>Scalar</td><td>A single float, the variance of x.</td></tr>
                        <tr><td>Gamma</td><td>$\gamma$</td><td>$[C]$</td><td>A learned scaling parameter vector.</td></tr>
                        <tr><td>Beta</td><td>$\beta$</td><td>$[C]$</td><td>A learned shifting parameter vector.</td></tr>
                        <tr><td>Output</td><td>$y$</td><td>$[C]$</td><td>The final 1D output vector.</td></tr>
                    </tbody>
                </table>
            </section>

            <!-- PART III: THE REVOLUTION -->
            <section data-section="revolution">
                <div class="section-progress">Part III: Revolution</div>
                <h2>The LayerNorm Revolution: BERT vs GPT-2</h2>
                <p class="smaller">How moving LayerNorm by 2 lines of code enabled the modern AI era</p>
                
                <div class="timeline">
                    <div class="timeline-item">
                        <div class="timeline-year">2017</div>
                        <div class="timeline-model">Original Transformer</div>
                    </div>
                    <div class="timeline-line"></div>
                    <div class="timeline-item">
                        <div class="timeline-year">2018</div>
                        <div class="timeline-model bert-color">BERT (12-24 layers)</div>
                    </div>
                    <div class="timeline-line"></div>
                    <div class="timeline-item">
                        <div class="timeline-year">2019</div>
                        <div class="timeline-model gpt-color">GPT-2 (48+ layers)</div>
                    </div>
                </div>
            </section>

            <section data-section="revolution">
                <h2>BERT's Approach: Post-LN (Normalizing After)</h2>
                <p class="smaller">The original approach normalized <span class="highlight">after</span> adding the residual connection.</p>
                
                <div class="two-col">
                    <div>
                        <svg class="viz-svg" viewBox="0 0 400 400">
                            <defs><marker id="arrowhead" markerWidth="8" markerHeight="6" refX="0" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#FFF"/></marker></defs>
                            <text x="200" y="30" class="svg-label" fill="var(--c-bert)">BERT-style Post-LN</text>
                            <text x="200" y="70" class="svg-text">Input (x)</text>
                            <path d="M200 80 V 110" class="svg-arrow"/>
                            <path d="M200 115 H 100 V 275 H 200" class="svg-dashed-arrow"/>
                            <rect x="150" y="115" width="100" height="50" class="svg-box" stroke="var(--c-purple)" fill="#3c2a4f"/>
                            <text x="200" y="145" class="svg-text">F(x)</text>
                            <path d="M200 165 V 195" class="svg-arrow"/>
                            <circle cx="200" cy="210" r="12" fill="var(--c-orange)"/>
                            <text x="200" y="215" class="svg-text">+</text>
                            <path d="M200 222 V 252" class="svg-arrow"/>
                            <rect x="125" y="252" width="150" height="50" class="svg-box" stroke="var(--c-red)" fill="#4c2e2e"/>
                            <text x="200" y="282" class="svg-text">LayerNorm</text>
                            <path d="M200 302 V 332" class="svg-arrow"/>
                            <text x="200" y="360" class="svg-text">Output</text>
                            
                            <!-- Variance indicator -->
                            <text x="300" y="220" class="svg-desc" fill="var(--c-red)">High Variance!</text>
                        </svg>
                    </div>
                    <div>
                        <h4>The Equation: <span class="bert-color">`y = LN(x + F(x))`</span></h4>
                        <p class="smaller">Problem: Before normalization, we compute `x + F(x)` which accumulates variance.</p>
                        
                        <h4 class="fragment">Training Symptoms:</h4>
                        <ul class="smaller fragment">
                            <li><span class="highlight">Loss oscillates wildly</span></li>
                            <li><span class="highlight">Gradients explode/vanish</span></li>
                            <li><span class="highlight">Poor pattern learning</span></li>
                            <li><span class="highlight">Requires 40K warmup steps</span></li>
                            <li><span class="highlight">Limited to ~30 layers</span></li>
                        </ul>
                    </div>
                </div>
            </section>

            <section data-section="revolution">
                <h2>GPT-2's Innovation: Pre-LN (Normalizing Before)</h2>
                <p class="smaller">The breakthrough: normalize <span class="highlight">before</span> the function, keeping the residual path clean.</p>
                
                <div class="two-col">
                    <div>
                        <svg class="viz-svg" viewBox="0 0 400 400">
                            <defs><marker id="arrowhead-pre" markerWidth="8" markerHeight="6" refX="0" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#FFF"/></marker></defs>
                            <text x="200" y="30" class="svg-label" fill="var(--c-gpt)">GPT-2 style Pre-LN</text>
                            <text x="200" y="70" class="svg-text">Input (x)</text>
                            <path d="M200 80 V 110" class="svg-arrow"/>
                            <path d="M200 115 H 100 V 315 H 200" class="svg-arrow" stroke="var(--c-green)"/>
                            <rect x="125" y="115" width="150" height="50" class="svg-box" stroke="var(--c-green)" fill="#2e4c44"/>
                            <text x="200" y="145" class="svg-text">LayerNorm</text>
                            <path d="M200 165 V 195" class="svg-arrow"/>
                            <rect x="150" y="195" width="100" height="50" class="svg-box" stroke="var(--c-purple)" fill="#3c2a4f"/>
                            <text x="200" y="225" class="svg-text">F(LN(x))</text>
                            <circle cx="200" cy="315" r="12" fill="var(--c-orange)"/>
                            <text x="200" y="318" class="svg-text">+</text>
                            <path d="M200 330 V 372" class="svg-arrow"/>
                            <text x="200" y="385" class="svg-text">Output</text>
                            
                            <!-- Clean path indicator -->
                            <text x="45" y="200" class="svg-desc" fill="var(--c-green)">Clean Path!</text>
                        </svg>
                    </div>
                    <div>
                        <h4>The Equation: <span class="gpt-color">`y = x + F(LN(x))`</span></h4>
                        <p class="smaller">Solution: The residual path `x` stays untouched, providing a clean gradient highway.</p>
                        
                        <h4 class="fragment">Training Benefits:</h4>
                        <ul class="smaller fragment">
                            <li><span class="highlight">Smooth loss convergence</span></li>
                            <li><span class="highlight">Stable gradients</span></li>
                            <li><span class="highlight">Excellent pattern learning</span></li>
                            <li><span class="highlight">Minimal/no warmup needed</span></li>
                            <li><span class="highlight">Scales to 100+ layers</span></li>
                        </ul>
                    </div>
                </div>
            </section>

            <section data-section="revolution">
                <h2>The Critical Mathematical Difference</h2>
                <p class="smaller">The gradient flow tells the whole story of why Pre-LN was revolutionary.</p>
                
                <div class="two-col">
                    <div>
                        <h4>Pre-LN Gradient Magic</h4>
                        <p class="smaller">The gradient of `y = x + F(LN(x))` with respect to `x` is:</p>
                        <p class="smaller highlight" style="text-align: center; font-size: 1.2em;">`dy/dx = 1 + dF/dx`</p>
                        <p class="smaller">That <span class="highlight">`1`</span> term is revolutionary:</p>
                        <ul class="smaller">
                            <li>Gradients never vanish (always ≥ 1)</li>
                            <li>Perfect gradient flow through residual path</li>
                            <li>Training stable at any depth</li>
                        </ul>
                    </div>
                    <div>
                        <svg class="viz-svg" viewBox="0 0 400 400">
                            <defs><marker id="grad-arrowhead" markerWidth="8" markerHeight="6" refX="0" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="var(--c-orange)"/></marker></defs>
                            
                            <text x="100" y="30" class="svg-label" fill="var(--c-red)">Post-LN</text>
                            <text x="300" y="30" class="svg-label" fill="var(--c-green)">Pre-LN</text>
                            
                            <!-- Post-LN unstable gradients -->
                            <text x="100" y="340" class="svg-desc">Layer 1</text>
                            <text x="100" y="260" class="svg-desc">Layer 10</text>
                            <text x="100" y="180" class="svg-desc">Layer 20</text>
                            <text x="100" y="100" class="svg-desc">Layer 30</text>
                            
                            <path d="M100 320 V 80" stroke="var(--c-red)" stroke-width="2" fill="none" class="fragment" data-fragment-index="1"/>
                            <path d="M100 320 V 80" stroke="var(--c-red)" stroke-width="8" opacity="0.8" fill="none" class="fragment" data-fragment-index="2"/>
                            <text x="100" y="60" class="svg-text" fill="var(--c-red)" class="fragment" data-fragment-index="2">EXPLODES!</text>
                            <path d="M100 350 V 90" class="svg-grad-arrow fragment" data-fragment-index="1" style="stroke-width: 2px;"/>
                            <path d="M100 350 V 90" class="svg-grad-arrow fragment" data-fragment-index="2" style="stroke-width: 5px;"/>
                            <path d="M100 350 V 90" class="svg-grad-arrow fragment" data-fragment-index="3" style="stroke-width: 10px; opacity: 0.8;"/>
                            <path d="M100 350 V 90" class="svg-grad-arrow fragment" data-fragment-index="4" style="stroke-width: 18px; opacity: 0.6;"/>
                            <text x="200" y="30" class="svg-text highlight fragment" data-fragment-index="4">EXPLODES!</text>
                            
                            <!-- Pre-LN stable gradients -->
                            <text x="300" y="340" class="svg-desc">Layer 1</text>
                            <text x="300" y="260" class="svg-desc">Layer 50</text>
                            <text x="300" y="180" class="svg-desc">Layer 96</text>
                            <text x="300" y="100" class="svg-desc">Layer 150</text>
                            
                            <path d="M300 320 V 80" stroke="var(--c-green)" stroke-width="4" fill="none"/>
                            <text x="300" y="60" class="svg-text" fill="var(--c-green)">STABLE!</text>
                        </svg>
                    </div>
                </div>
            </section>

            <section data-section="revolution">
                <h2>The Code Change That Changed Everything</h2>
                <p class="smaller">This architectural revolution was literally <span class="highlight">moving 2 lines of code</span>.</p>
                
                <div class="two-col">
                    <div>
                        <h4 class="bert-color">BERT-style (Post-LN)</h4>
                        <pre class="smaller" style="background: #2d2d2d; padding: 15px; border-radius: 8px; border: 2px solid var(--c-bert);">
<code style="color: #f8f8f2;">def transformer_block(x):
    # Attention or MLP
    out = function(x)
    # Add residual
    out = x + out
    # Normalize AFTER addition
    out = layer_norm(out)
    return out</code></pre>
                    </div>
                    <div>
                        <h4 class="gpt-color">GPT-2 style (Pre-LN)</h4>
                        <pre class="smaller" style="background: #2d2d2d; padding: 15px; border-radius: 8px; border: 2px solid var(--c-gpt);">
<code style="color: #f8f8f2;">def transformer_block(x):
    # Normalize BEFORE function
    norm_x = layer_norm(x)
    # Attention or MLP on normalized input
    out = function(norm_x)
    # Add to original (clean path)
    out = x + out
    return out</code></pre>
                    </div>
                </div>
                
                <div class="fragment" style="margin-top: 30px; text-align: center;">
                    <p class="highlight">Moving `layer_norm()` from line 4 to line 2 enabled GPT-3, ChatGPT, and the entire modern LLM era.</p>
                </div>
            </section>

            <!-- PART IV: THE IMPLEMENTATION -->
            <section data-section="implementation">
                <div class="section-progress">Part IV: Implementation</div>
               <div class="bg-white p-6 rounded-2xl shadow-lg w-full" style="transform: scale(0.9);">
        <svg viewBox="0 0 1400 850" xmlns="http://www.w3.org/2000/svg" class="w-full">
            <!-- Defs -->
            <defs>
                <linearGradient id="grad-dram" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#a5b4fc"/><stop offset="100%" stop-color="#6366f1"/></linearGradient>
                <linearGradient id="grad-cpu" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#7dd3fc"/><stop offset="100%" stop-color="#0ea5e9"/></linearGradient>
                <linearGradient id="grad-cache-l3" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#f9a8d4"/><stop offset="100%" stop-color="#ec4899"/></linearGradient>
                <linearGradient id="grad-cache-l2" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#a7f3d0"/><stop offset="100%" stop-color="#34d399"/></linearGradient>
                <linearGradient id="grad-cache-l1" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#fde047"/><stop offset="100%" stop-color:#facc15/></linearGradient>
                <linearGradient id="grad-exec" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" stop-color="#d8b4fe"/><stop offset="100%" stop-color="#a855f7"/></linearGradient>
                <marker id="arrowhead-memory" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="#475569"/></marker>
                <marker id="arrowhead-white" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="white"/></marker>
            </defs>

            <!-- Title -->
            <text x="700" y="40" text-anchor="middle" class="title" style="color:white;">End-to-End LayerNorm: Memory Layout to Core Execution</text>

            <!-- Main Memory (DRAM) -->
            <g id="dram" class="fragment" data-fragment-index="1">
                <rect x="50" y="80" width="300" height="730" rx="15" fill="url(#grad-dram)" stroke="#4f46e5" stroke-width="2"/>
                <text x="200" y="110" text-anchor="middle" class="label" fill="white">Main Memory (DRAM)</text>
                
                <!-- Memory Layout -->
                <g id="memory-layout">
                    <rect x="70" y="140" width="260" height="130" rx="5" fill="white" fill-opacity="0.6"/>
                    <text x="200" y="160" text-anchor="middle" class="mono-label">...</text>
                    
                    <g id="aligned-slices">
                        <rect x="70" y="275" width="260" height="180" rx="5" fill="#fef08a" fill-opacity="0.4" stroke="#f59e0b" stroke-width="1.5"/>
                        <text x="200" y="295" text-anchor="middle" class="small-label">L->layer_input_offset</text>
                        <rect x="80" y="315" width="240" height="35" rx="3" fill="#fef9c3"/><text x="200" y="335" text-anchor="middle" class="small-label">Token Slice 0</text>
                        <rect x="80" y="360" width="240" height="35" rx="3" fill="#fef9c3"/><text x="200" y="380" text-anchor="middle" class="small-label">Token Slice 1</text>
                        <rect x="80" y="410" width="240" height="30" rx="3" fill="#e2e8f0" fill-opacity="0.7"/><text x="200" y="425" text-anchor="middle" class="small-label" fill="#64748b">Padding (align_up)</text>
                        <text x="200" y="480" text-anchor="middle" class="sub-label" fill="#333">Aligned to Prevent False Sharing</text>
                    </g>
                    
                    <rect x="70" y="490" width="260" height="40" rx="5" fill="#f9a8d4" fill-opacity="0.8" stroke="#db2777" stroke-width="1.5"/><text x="200" y="515" text-anchor="middle" class="small-label">L->ln1_weight_offset (gamma)</text>
                    <rect x="70" y="535" width="260" height="40" rx="5" fill="#f9a8d4" fill-opacity="0.8" stroke="#db2777" stroke-width="1.5"/><text x="200" y="560" text-anchor="middle" class="small-label">L->ln1_bias_offset (beta)</text>

                    <rect x="70" y="580" width="260" height="40" rx="5" fill="#fff" stroke="#8b5cf6" stroke-width="1.5"/><text x="200" y="605" text-anchor="middle" class="small-label">L->ln1_mean_offset</text>
                    <rect x="70" y="625" width="260" height="40" rx="5" fill="#fff" stroke="#8b5cf6" stroke-width="1.5"/><text x="200" y="650" text-anchor="middle" class="small-label">L->ln1_rstd_offset</text>
                    <rect x="70" y="670" width="260" height="120" rx="5" fill="#a7f3d0" fill-opacity="0.8" stroke="#10b981" stroke-width="1.5"/><text x="200" y="730" text-anchor="middle" class="small-label">L->ln1_output_offset</text>
                </g>
            </g>

            <!-- CPU Block -->
            <g id="cpu-block" class="fragment" data-fragment-index="2">
                <rect x="400" y="80" width="990" height="730" rx="15" fill="url(#grad-cpu)" stroke="#0284c7" stroke-width="2"/>
                <text x="875" y="110" text-anchor="middle" class="label" fill="white">CPU</text>
                <rect x="420" y="140" width="910" height="60" rx="10" fill="url(#grad-cache-l3)" stroke="#db2777" stroke-width="1.5"/><text x="875" y="175" text-anchor="middle" class="label" fill="white">Shared L3 Cache</text>

                <!-- Core 0 - Detailed View -->
                <g id="core0">
                    <rect x="430" y="220" width="500" height="570" rx="10" fill="white" fill-opacity="0.6"/>
                    <text x="680" y="245" text-anchor="middle" class="label">Core 0</text>
                    <rect x="585" y="260" width="190" height="40" rx="5" fill="url(#grad-cache-l2)"/><text x="680" y="285" text-anchor="middle" class="small-label">L2 Cache</text>
                    <rect x="610" y="310" width="140" height="40" rx="5" fill="url(#grad-cache-l1)"/><text x="680" y="335" text-anchor="middle" class="small-label">L1 Cache</text>
                    
                    <!-- Execution Unit -->
                    <g id="execution-unit">
                        <rect x="450" y="370" width="460" height="400" rx="5" fill="url(#grad-exec)" fill-opacity="0.8"/>
                        <text x="680" y="395" text-anchor="middle" class="label" fill="white">Execution Unit</text>
                        
                        <!-- AVX-512 Register -->
                        <g id="avx-register">
                            <text x="680" y="420" text-anchor="middle" class="exec-label">AVX-512 ZMM Register (16 x 32-bit floats)</text>
                            <rect x="470" y="430" width="420" height="30" rx="2" fill="white" fill-opacity="0.3"/>
                            <path d="M 496.25 430 V 460 M 522.5 430 V 460 M 548.75 430 V 460 M 575 430 V 460 M 601.25 430 V 460 M 627.5 430 V 460 M 653.75 430 V 460 M 680 430 V 460 M 706.25 430 V 460 M 732.5 430 V 460 M 758.75 430 V 460 M 785 430 V 460 M 811.25 430 V 460 M 837.5 430 V 460 M 863.75 430 V 460" stroke="white" stroke-width="1" stroke-opacity="0.5"/>
                        </g>

                        <!-- Pass 1 -->
                        <text x="550" y="490" text-anchor="middle" class="exec-label">Pass 1: Mean</text>
                        <text x="550" y="505" text-anchor="middle" class="mono-label" fill="white">_mm512_add_ps</text>
                        <path class="arrow-path" stroke="white" marker-end="url(#arrowhead-white)" d="M 680,465 V 520"/>
                        <rect x="630" y="520" width="100" height="30" rx="5" fill="white" fill-opacity="0.3"/>
                        <text x="680" y="540" text-anchor="middle" class="small-label" fill="white">sum_vec</text>

                        <!-- Pass 2 -->
                        <text x="550" y="580" text-anchor="middle" class="exec-label">Pass 2: Variance</text>
                        <text x="550" y="595" text-anchor="middle" class="mono-label" fill="white">_mm512_fmadd_ps</text>
                        <path class="arrow-path" stroke="white" marker-end="url(#arrowhead-white)" d="M 680,555 V 610"/>
                        <rect x="630" y="610" width="100" height="30" rx="5" fill="white" fill-opacity="0.3"/>
                        <text x="680" y="630" text-anchor="middle" class="small-label" fill="white">var_vec</text>
                        
                        <!-- Pass 3 -->
                        <text x="550" y="670" text-anchor="middle" class="exec-label">Pass 3: Normalize</text>
                        <text x="550" y="685" text-anchor="middle" class="mono-label" fill="white">_mm512_fmadd_ps</text>
                        <path class="arrow-path" stroke="white" marker-end="url(#arrowhead-white)" d="M 680,645 V 700"/>
                        <rect x="630" y="700" width="100" height="30" rx="5" fill="white" fill-opacity="0.3"/>
                        <text x="680" y="720" text-anchor="middle" class="small-label" fill="white">output_vec</text>
                    </g>
                </g>
                <!-- Other Cores Simplified -->
                <g id="core1"><rect x="950" y="220" width="190" height="570" rx="10" fill="white" fill-opacity="0.6"/><text x="1045" y="245" text-anchor="middle" class="label">Core 1</text></g>
                <g id="coreN"><rect x="1160" y="220" width="190" height="570" rx="10" fill="white" fill-opacity="0.6"/><text x="1255" y="245" text-anchor="middle" class="label">Core N</text></g>
            </g>

            <!-- Data Flow Arrows -->
             <g class="fragment" data-fragment-index="3">
            <path class="arrow-path gamma-path" stroke="#db2777" marker-end="url(#arrowhead-memory)" d="M 335,535 C 380,535 380,170 415,170" /><text x="375" y="350" class="sub-label" fill="#db2777">1. γ & β to L3</text>
            <path class="arrow-path" stroke="#db2777" marker-end="url(#arrowhead-memory)" d="M 680,198 V 205" /><text x="885" y="213" text-anchor="middle" class="sub-label" fill="#333">2. Distribute to cores</text>
            <path class="arrow-path" stroke="#db2777" marker-end="url(#arrowhead-memory)" d="M 1050,198 V 205" />
            <path class="arrow-path" stroke="#db2777" marker-end="url(#arrowhead-memory)" d="M 1250,198 V 205" />
            <path class="arrow-path data-path" stroke="#4f46e5" marker-end="url(#arrowhead-memory)" d="M 335,335 C 450,335 500,335 605,335" /><text x="380" y="295" class="sub-label" fill="#4f46e5">3. Aligned token slices to L1</text>
            <path class="arrow-path data-path" stroke="#a16207" marker-end="url(#arrowhead-memory)" d="M 680,355 V 365" /><text x="680" y="365" text-anchor="middle" class="sub-label" fill="#a16207">4. Feed L1 data</text>
            
            <!-- Store & Write-back Arrows -->
            <path class="arrow-path" stroke="#8b5cf6" marker-end="url(#arrowhead-memory)" d="M 630,535 H 400 C 370,535 370,605 355,605" /><text x="450" y="560" class="sub-label" fill="#8b5cf6">Store mean</text>
            <path class="arrow-path" stroke="#8b5cf6" marker-end="url(#arrowhead-memory)" d="M 630,625 H 400 C 370,625 370,650 355,650" /><text x="450" y="650" class="sub-label" fill="#8b5cf6">Store rstd</text>
            <path class="arrow-path data-path" stroke="#16a34a" marker-end="url(#arrowhead-memory)" d="M 630,715 H 400 C 370,715 370,730 355,730" /><text x="450" y="740" class="sub-label" fill="#16a34a">5. Write back final output</text>
             </g>
        </svg>
    </div> 
            </section>
            <section data-section="implementation">
                <h2>SIMD Optimization</h2>
                <div style="text-align: left;">
                    <pre class="smaller" style="height:650px;">
<code data-line-numbers="27-44|45-74|75-100">// High-performance LayerNorm with 4-way SIMD unrolling
// ============================================================================
// LAYER NORMALIZATION (Optimized for a single thread's token slice, ROLLED version)
// This version uses AVX-512 but without explicit 4-way loop unrolling,
// processing 16 floats per iteration.
// ============================================================================

// Fixed slice processing function with improved numerical stability
void layernorm_forward_rolled_slice(const float *__restrict input_slice_base,
                                    const float *__restrict gamma,
                                    const float *__restrict beta,
                                    float *__restrict output_slice_base,
                                    float *__restrict mean_cache_slice,
                                    float *__restrict rstd_cache_slice,
                                    int num_tokens_in_slice,
                                    int d_model,
                                    int aligned_embed_dim,
                                    float eps)
{
    for (int t = 0; t < num_tokens_in_slice; ++t)
    {
        // Use aligned_embed_dim for memory layout (cache alignment)
        const float *in_ptr_token = input_slice_base + t * aligned_embed_dim;
        float *out_ptr_token = output_slice_base + t * aligned_embed_dim;

        // ───────────────────────────────────────────
        // Pass 1: Compute mean (AVX-512, rolled)
        // ───────────────────────────────────────────
        __m512 acc_sum_vec = _mm512_setzero_ps();
        int j = 0;
        for (; j <= d_model - 16; j += 16)
        {
            _mm_prefetch((const char *)(in_ptr_token + j + 128), _MM_HINT_T0);
            __m512 v = _mm512_load_ps(in_ptr_token + j);
            acc_sum_vec = _mm512_add_ps(acc_sum_vec, v);
        }
        float mean = _mm512_reduce_add_ps(acc_sum_vec);
        for (; j < d_model; ++j)
        {
            mean += in_ptr_token[j];
        }
        mean /= (float)d_model;
        __m512 mean_vec = _mm512_set1_ps(mean);

        // ───────────────────────────────────────────
        // Pass 2: Compute variance (AVX-512, rolled)
        // ───────────────────────────────────────────
        __m512 acc_var_vec = _mm512_setzero_ps();
        j = 0;
        for (; j <= d_model - 16; j += 16)
        {
            _mm_prefetch((const char *)(in_ptr_token + j + 128), _MM_HINT_T0);
            __m512 v = _mm512_load_ps(in_ptr_token + j);
            __m512 diff = _mm512_sub_ps(v, mean_vec);
            acc_var_vec = _mm512_fmadd_ps(diff, diff, acc_var_vec);
        }
        float var = _mm512_reduce_add_ps(acc_var_vec);
        for (; j < d_model; ++j)
        {
            float diff = in_ptr_token[j] - mean;
            var += diff * diff;
        }
        var = var / (float)d_model + eps;
        // if (t == 0) printf("FIXED FUNC: var=%.9f, about to calculate sqrt\n", var);

        // FIXED: Use double precision for more stable sqrt computation
        double var_double = (double)var;
        float inv_std = (float)(1.0 / sqrt(var_double));
        __m512 inv_std_vec = _mm512_set1_ps(inv_std);

        // Store mean and rstd for the backward pass
        mean_cache_slice[t] = mean;
        rstd_cache_slice[t] = inv_std;

        // ───────────────────────────────────────────
        // Pass 3: Normalize, scale, shift (AVX-512, rolled)
        // ───────────────────────────────────────────
        j = 0;
        for (; j <= d_model - 16; j += 16)
        {
            _mm_prefetch((const char *)(in_ptr_token + j + 128), _MM_HINT_T0);
            _mm_prefetch((const char *)(gamma + j + 128), _MM_HINT_T0);
            _mm_prefetch((const char *)(beta + j + 128), _MM_HINT_T0);

            __m512 v = _mm512_load_ps(in_ptr_token + j);
            __m512 g = _mm512_load_ps(gamma + j);
            __m512 b = _mm512_load_ps(beta + j);

            __m512 n = _mm512_mul_ps(_mm512_sub_ps(v, mean_vec), inv_std_vec);
            __m512 o = _mm512_fmadd_ps(n, g, b);

            _mm512_store_ps(out_ptr_token + j, o);
        }
        for (; j < d_model; ++j)
        {
            float normed = (in_ptr_token[j] - mean) * inv_std;
            out_ptr_token[j] = normed * gamma[j] + beta[j];
        }
    }
}
</code></pre>
                </div>
                <div class="smaller" style="margin-top: 20px;">
                    <p><span class="highlight">Performance gains:</span> 8-12x speedup over naive implementation</p>
                    <p><span class="highlight">Memory bandwidth:</span> ~80% of theoretical peak</p>
                    <p><span class="highlight">Cache efficiency:</span> 90%+ L1 hit rate</p>
                </div>
            </section>

            <section data-section="conclusion">
                <h2>The Lasting Impact</h2>
                <p class="smaller">LayerNorm represents a perfect example of how deep understanding across multiple layers creates transformative technology.</p>
                
                <div class="three-col" style="margin-top: 40px;">
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 50px; color: var(--c-blue);">🧮</div>
                        <h4>Mathematical Insight</h4>
                        <p class="smaller">Understanding internal covariate shift led to the LayerNorm formula</p>
                    </div>
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 50px; color: var(--c-green);">⚡</div>
                        <h4>Architectural Innovation</h4>
                        <p class="smaller">Moving 2 lines of code enabled the modern AI revolution</p>
                    </div>
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 50px; color: var(--c-purple);">🚀</div>
                        <h4>Implementation Excellence</h4>
                        <p class="smaller">SIMD optimization makes it production-ready at scale</p>
                    </div>
                </div>
                
                <div class="fragment" style="margin-top: 40px; text-align: center;">
                    <div style="border: 3px solid var(--c-orange); padding: 30px; border-radius: 15px; background: rgba(255, 167, 38, 0.1);">
                        <h3 style="color: var(--c-orange);">The LayerNorm Legacy</h3>
                        <p class="smaller">Without LayerNorm's mathematical foundation, GPT-2's architectural insight, and modern HPC implementation:</p>
                        <p class="highlight">No ChatGPT • No GPT-4 • No modern AI revolution</p>
                    </div>
                </div>
            </section>

        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/plugin/math/math.js"></script>
    <script src="../reveal.js/plugin/highlight/highlight.js"></script>
  <script src="../reveal.js/plugin/zoom/zoom.js"></script>
    <script>
        Reveal.initialize({
            controls: true,
            progress: true,
            center: true,
            hash: true,
            width: 1600,
            height: 900,
            transition: 'slide',
            plugins: [RevealZoom, RevealMath.MathJax2, RevealHighlight ]
        });

        // Chart.js visualizations
        function createProblemChart() {
            const ctx = document.getElementById('problemChart');
            if (!ctx) return;
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array.from({length: 100}, (_, i) => i),
                    datasets: [{
                        label: 'Early Training',
                        data: Array.from({length: 100}, () => Math.random() * 0.5 + 0.25),
                        borderColor: '#66bb6a',
                        backgroundColor: 'rgba(102, 187, 106, 0.1)',
                        borderWidth: 2
                    }, {
                        label: 'Mid Training', 
                        data: Array.from({length: 100}, () => Math.random() * 2 + 1),
                        borderColor: '#ffa726',
                        backgroundColor: 'rgba(255, 167, 38, 0.1)',
                        borderWidth: 2
                    }, {
                        label: 'Late Training',
                        data: Array.from({length: 100}, () => Math.random() * 4 + 2),
                        borderColor: '#ef5350', 
                        backgroundColor: 'rgba(239, 83, 80, 0.1)',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: true, text: 'Activation Distributions During Training (Internal Covariate Shift)' }
                    },
                    scales: {
                        y: { beginAtZero: true, title: { display: true, text: 'Activation Value' } },
                        x: { title: { display: true, text: 'Feature Dimension' } }
                    }
                }
            });
        }

        function createBeforeAfterCharts() {
            // Before LayerNorm
            const beforeCtx = document.getElementById('beforeChart');
            if (beforeCtx) {
                new Chart(beforeCtx, {
                    type: 'line',
                    data: {
                        labels: Array.from({length: 50}, (_, i) => i),
                        datasets: [{
                            label: 'Chaotic Distribution',
                            data: Array.from({length: 50}, () => Math.random() * 6 - 1),
                            borderColor: '#ef5350',
                            backgroundColor: 'rgba(239, 83, 80, 0.1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { min: -3, max: 6 },
                            x: { display: false }
                        }
                    }
                });
            }

            // After LayerNorm  
            const afterCtx = document.getElementById('afterChart');
            if (afterCtx) {
                new Chart(afterCtx, {
                    type: 'line', 
                    data: {
                        labels: Array.from({length: 50}, (_, i) => i),
                        datasets: [{
                            label: 'Normalized Distribution',
                            data: Array.from({length: 50}, () => Math.random() * 2 - 1),
                            borderColor: '#66bb6a',
                            backgroundColor: 'rgba(102, 187, 106, 0.1)', 
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { min: -3, max: 6 },
                            x: { display: false }
                        }
                    }
                });
            }
        }

        // Photo animations for LayerNorm analogy
        function setupPhotoAnimations() {
            const badPhoto = document.getElementById('bad-photo');
            if (badPhoto) {
                gsap.to(badPhoto, {
                    filter: 'sepia(0.6) brightness(0.7) hue-rotate(20deg)',
                    duration: 1.5,
                    yoyo: true,
                    repeat: -1,
                    ease: "power1.inOut"
                });
                
                gsap.to(badPhoto, {
                    filter: 'saturate(2) brightness(1.3) hue-rotate(-10deg)',
                    duration: 1.2,
                    yoyo: true,
                    repeat: -1,
                    ease: "power1.inOut",
                    delay: 0.7
                });
            }
        }

        function setupInteractiveStyling() {
            const gammaSlider = document.getElementById('gamma');
            const betaBrightnessSlider = document.getElementById('beta-brightness');
            const betaTintSlider = document.getElementById('beta-tint');
            const stylizedPhoto = document.getElementById('stylized-photo');

            if (!gammaSlider || !stylizedPhoto) return;

            function updateStyle() {
                const gamma = gammaSlider.value / 100;
                const brightness = betaBrightnessSlider.value / 100;
                const tint = betaTintSlider.value;

                gsap.set(stylizedPhoto, {
                    filter: `contrast(${gamma}) brightness(${brightness}) sepia(${tint}%)`
                });
            }

            gammaSlider.addEventListener('input', updateStyle);
            betaBrightnessSlider.addEventListener('input', updateStyle);
            betaTintSlider.addEventListener('input', updateStyle);
            
            updateStyle();
        }

        // Initialize everything when reveal.js is ready
        Reveal.on('ready', event => {
            createProblemChart();
            createBeforeAfterCharts();
            setupPhotoAnimations();
            setupInteractiveStyling();
        });

        // Section progress tracking
        Reveal.on('slidechanged', event => {
            const section = event.currentSlide.dataset.section;
            const progressElements = document.querySelectorAll('.section-progress');
            
            const sectionNames = {
                'intro': 'Part I: Foundation',
                'math': 'Part II: Mathematics', 
                'revolution': 'Part III: Revolution',
                'implementation': 'Part IV: Implementation',
                'conclusion': 'Part V: Complete Picture'
            };
            
            progressElements.forEach(el => {
                if (section && sectionNames[section]) {
                    el.textContent = sectionNames[section];
                }
            });
        });
    </script>
</body>
</html>