<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>LayerNorm: The Complete Story</title>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reset.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/theme/black.css" id="theme">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
        :root {
            --r-main-font: 'Inter', sans-serif;
            --r-heading-font: 'Inter', sans-serif;
            --c-blue: #42a5f5;
            --c-green: #66bb6a;
            --c-orange: #ffa726;
            --c-red: #ef5350;
            --c-purple: #ab47bc;
            --c-gray: #37474f;
            --c-bert: #ff6b6b;
            --c-gpt: #4ecdc4;
            --c-bg: #263238;
            --c-text: #eceff1;
        }
        .reveal { 
            font-family: var(--r-main-font); 
            font-size: 20px;
            background-color: #1a1a1a;
        }
        .reveal h1, .reveal h2, .reveal h3, .reveal h4 { 
            text-transform: none; 
            font-weight: 700; 
            color: var(--c-text); 
        }
        .reveal .highlight { color: var(--c-orange); }
        .reveal .bert-color { color: var(--c-bert); }
        .reveal .gpt-color { color: var(--c-gpt); }
        .reveal .dim { color: #90a4ae; }
        .reveal .smaller { font-size: 0.8em; }
        .reveal .tiny { font-size: 0.7em; }

        /* SVG Styles */
        .viz-svg { 
            width: 100%; 
            height: auto; 
            background-color: var(--c-bg); 
            border-radius: 10px; 
            margin-top: 10px; 
        }
        .svg-text { 
            font-family: var(--r-main-font); 
            fill: white; 
            text-anchor: middle; 
            font-size: 10px; 
        }
        .svg-label { font-size: 11px; font-weight: bold; }
        .svg-desc { font-size: 9px; fill: #ccc; }
        .svg-box { stroke-width: 2px; rx: 5; }
        .svg-arrow { stroke: #eee; stroke-width: 2px; fill: none; marker-end: url(#arrowhead); }
        .svg-dashed-arrow { stroke: #ccc; stroke-width: 2px; fill: none; marker-end: url(#arrowhead); stroke-dasharray: 5 5; }
        .svg-grad-arrow { stroke: var(--c-orange); stroke-width: 3px; fill: none; marker-end: url(#grad-arrowhead); stroke-dasharray: 8 4; }

        /* Layout */
        .two-col { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; align-items: start; }
        .three-col { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; align-items: center; }
        .two-col .viz-svg { transform: scale(0.85); transform-origin: center center; }

        /* Photo elements */
        .photo-container { display: flex; justify-content: space-around; align-items: center; width: 100%; margin-top: 20px; }
        .photo-card {
            background-color: var(--c-bg);
            border-radius: 15px;
            padding: 15px;
            width: 280px;
            height: 320px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 1px solid #455a64;
        }
        .photo-element {
            width: 240px;
            height: 160px;
            background-image: url('https://images.unsplash.com/photo-1506744038136-46273834b3fb?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1170&q=80');
            background-size: cover;
            background-position: center;
            border-radius: 8px;
        }
        .slider-controls { width: 240px; }
        .slider-group { margin: 15px 0; }
        .slider-group label { display: block; margin-bottom: 8px; font-weight: bold; font-size: 0.8em; }
        input[type="range"] { width: 100%; }

        /* Chart containers */
        .chart-container { width: 80%; max-width: 500px; margin: 15px auto; }
        .dual-chart-container { display: flex; justify-content: space-around; width: 100%; }
        .chart-half { width: 45%; }
        .stats-box { background: rgba(255, 255, 255, 0.05); border-radius: 8px; padding: 8px; margin-top: 8px; }
        .stats-box p { margin: 3px 0; font-size: 0.7em; }

        /* Math insight boxes */
        .math-insight { 
            background: rgba(66, 175, 250, 0.1); 
            border: 2px solid var(--c-blue); 
            border-radius: 8px; 
            padding: 15px; 
            margin: 15px 0; 
        }
        .math-insight h4 { color: var(--c-blue); margin-bottom: 8px; }

        /* Timeline */
        .timeline { display: flex; justify-content: space-around; align-items: center; margin: 20px 0; }
        .timeline-item { text-align: center; position: relative; }
        .timeline-year { font-size: 18px; font-weight: bold; color: var(--c-orange); }
        .timeline-model { font-size: 12px; margin-top: 5px; }
        .timeline-line { height: 3px; background: linear-gradient(90deg, var(--c-bert) 0%, var(--c-gpt) 100%); flex-grow: 1; margin: 0 10px; }

        /* Progress indicators */
        .section-progress {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 0.7em;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">

            <!-- PART I: THE FOUNDATION -->
            <section data-section="intro">
                <div class="section-progress">Part I: Foundation</div>
                <h1>LayerNorm: The Complete Story</h1>
                <h3>From Mathematical Foundation to Modern AI Revolution</h3>
                <p class="dim">What it is â€¢ Why it matters â€¢ How it works â€¢ When it changed everything</p>
                
                <div style="margin-top: 40px;">
                    <div class="three-col">
                        <div style="text-align: center;">
                            <div style="font-size: 40px; color: var(--c-blue);">ðŸ§®</div>
                            <h4>Mathematics</h4>
                            <p class="smaller dim">Internal covariate shift<br>Distribution control</p>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 40px; color: var(--c-orange);">âš¡</div>
                            <h4>Revolution</h4>
                            <p class="smaller dim">BERT â†’ GPT-2<br>Architectural breakthrough</p>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 40px; color: var(--c-green);">ðŸ”§</div>
                            <h4>Implementation</h4>
                            <p class="smaller dim">HPC optimization<br>Memory & SIMD</p>
                        </div>
                    </div>
                </div>
            </section>

            <section data-section="intro">
                <h2>The Problem: Internal Covariate Shift</h2>
                <p class="smaller">Neural networks work best when inputs have stable statistical properties, but deep networks naturally create chaos.</p>
                
                <div class="chart-container">
                    <canvas id="problemChart" width="600" height="300"></canvas>
                </div>
                
                <div class="math-insight">
                    <h4>ðŸŽ¯ The Core Problem</h4>
                    <p class="smaller">As network weights change during training, the distribution of activations constantly shifts. Later layers can't learn stable patterns when their inputs are chaotic.</p>
                </div>
            </section>

            <section data-section="intro">
                <h2>What Does "Variance" Actually Mean?</h2>
                <p class="smaller">Let's make this concrete. "High variance" means <span class="highlight">unpredictable, chaotic signals</span> that make learning impossible.</p>
                
                <div style="text-align: center;">
                    <svg class="viz-svg" viewBox="0 0 800 300">
                        <defs>
                            <marker id="arrowhead" markerWidth="8" markerHeight="6" refX="0" refY="3" orient="auto">
                                <polygon points="0 0, 8 3, 0 6" fill="#FFF"/>
                            </marker>
                        </defs>
                        <text x="400" y="30" class="svg-label">Signal Behavior: Stable vs Chaotic</text>
                        
                        <!-- Stable signal -->
                        <text x="200" y="60" class="svg-label" fill="var(--c-green)">Low Variance (Good)</text>
                        <path d="M50 150 Q 100 140 150 145 Q 200 150 250 148 Q 300 145 350 147" 
                              stroke="var(--c-green)" stroke-width="3" fill="none"/>
                        <text x="200" y="180" class="svg-desc">Predictable, learnable patterns</text>
                        <text x="200" y="200" class="svg-desc">Network can focus on learning</text>
                        
                        <!-- Chaotic signal -->
                        <text x="600" y="60" class="svg-label" fill="var(--c-red)">High Variance (Bad)</text>
                        <path d="M450 100 Q 500 200 550 80 Q 600 180 650 120 Q 700 90 750 170" 
                              stroke="var(--c-red)" stroke-width="3" fill="none"/>
                        <text x="600" y="180" class="svg-desc">Chaotic, unpredictable jumps</text>
                        <text x="600" y="200" class="svg-desc">Network fights chaos, not learning</text>
                        
                        <!-- Layer progression -->
                        <text x="50" y="270" class="svg-desc">Layer 1</text>
                        <text x="150" y="270" class="svg-desc">Layer 5</text>
                        <text x="250" y="270" class="svg-desc">Layer 10</text>
                        <text x="350" y="270" class="svg-desc">Layer 15</text>
                        
                        <text x="450" y="270" class="svg-desc">Layer 1</text>
                        <text x="550" y="270" class="svg-desc">Layer 5</text>
                        <text x="650" y="270" class="svg-desc">Layer 10</text>
                        <text x="750" y="270" class="svg-desc">Layer 15</text>
                    </svg>
                </div>
            </section>

            <!-- PART II: THE MATH -->
            <section data-section="math">
                <div class="section-progress">Part II: Mathematics</div>
                <h2>LayerNorm: The Photo Editor's Solution</h2>
                <p class="smaller">Think of each layer as a photo editor. High variance = chaotic, flickering input. LayerNorm = giving each editor a clean, neutral canvas first.</p>
                
                <div class="photo-container">
                    <div class="photo-card">
                        <h4>Raw Input (Chaotic)</h4>
                        <div id="bad-photo" class="photo-element"></div>
                        <p class="smaller dim">Flickering brightness, random colors</p>
                    </div>
                    <div style="font-size: 60px; color: var(--c-orange);">â†’</div>
                    <div class="photo-card">
                        <h4>After LayerNorm</h4>
                        <div id="neutral-photo" class="photo-element"></div>
                        <p class="smaller dim">Clean, neutral canvas</p>
                    </div>
                </div>
            </section>

            <section data-section="math">
                <h2>The Math: Forcing Stable Distributions</h2>
                <p class="smaller">LayerNorm ensures every layer receives inputs with mean=0, variance=1, then learns the perfect adjustments.</p>
                
                <div class="dual-chart-container">
                    <div class="chart-half">
                        <h4 style="color: var(--c-red); text-align: center;">Raw Activations (No Normalization)</h4>
                        <canvas id="beforeChart" width="300" height="200"></canvas>
                        <div class="stats-box">
                            <p>Î¼ = 2.3 (shifting)</p>
                            <p>ÏƒÂ² = 5.7 (growing)</p>
                            <p>Training: Unstable</p>
                        </div>
                    </div>
                    <div class="chart-half">
                        <h4 style="color: var(--c-green); text-align: center;">Normalized Activations (LayerNorm Applied)</h4>
                        <canvas id="afterChart" width="300" height="200"></canvas>
                        <div class="stats-box">
                            <p>Î¼ = 0.0 (stable)</p>
                            <p>ÏƒÂ² = 1.0 (controlled)</p>
                            <p>Training: Stable</p>
                        </div>
                    </div>
                </div>
                
                <div class="math-insight fragment">
                    <h4>The Formula</h4>
                    <p style="text-align: center; font-size: 1.2em;">
                        <span class="highlight">output = Î³ Ã— (x - Î¼) / âˆš(ÏƒÂ² + Îµ) + Î²</span>
                    </p>
                    <p class="smaller">Where Î¼ and ÏƒÂ² are computed per token across embedding dimensions</p>
                </div>
            </section>

            <section data-section="math">
                <h2>Interactive: The Î³ and Î² Parameters</h2>
                <p class="smaller">LayerNorm first creates a neutral canvas, then learns the perfect Î³ (scaling) and Î² (shifting) for each layer.</p>
                
                <div class="photo-container">
                    <div class="photo-card">
                        <h4>Neutral Canvas</h4>
                        <div class="photo-element"></div>
                    </div>
                    <div class="photo-card slider-controls">
                        <h4>Learnable Parameters</h4>
                        <div class="slider-group">
                            <label for="gamma">Gamma (Î³) - <span class="highlight">Contrast</span></label>
                            <input type="range" id="gamma" min="50" max="200" value="100">
                        </div>
                        <div class="slider-group">
                            <label for="beta-brightness">Beta (Î²) - <span class="highlight">Brightness</span></label>
                            <input type="range" id="beta-brightness" min="50" max="150" value="100">
                        </div>
                        <div class="slider-group">
                            <label for="beta-tint">Beta (Î²) - <span class="highlight">Color Tint</span></label>
                            <input type="range" id="beta-tint" min="0" max="50" value="0">
                        </div>
                    </div>
                    <div class="photo-card">
                        <h4>Final Output</h4>
                        <div id="stylized-photo" class="photo-element"></div>
                    </div>
                </div>
            </section>

            <!-- PART III: THE REVOLUTION -->
            <section data-section="revolution">
                <div class="section-progress">Part III: Revolution</div>
                <h2>The LayerNorm Revolution: BERT vs GPT-2</h2>
                <p class="smaller">How moving LayerNorm by 2 lines of code enabled the modern AI era</p>
                
                <div class="timeline">
                    <div class="timeline-item">
                        <div class="timeline-year">2017</div>
                        <div class="timeline-model">Original Transformer</div>
                    </div>
                    <div class="timeline-line"></div>
                    <div class="timeline-item">
                        <div class="timeline-year">2018</div>
                        <div class="timeline-model bert-color">BERT (12-24 layers)</div>
                    </div>
                    <div class="timeline-line"></div>
                    <div class="timeline-item">
                        <div class="timeline-year">2019</div>
                        <div class="timeline-model gpt-color">GPT-2 (48+ layers)</div>
                    </div>
                </div>
            </section>

            <section data-section="revolution">
                <h2>BERT's Approach: Post-LN (Normalizing After)</h2>
                <p class="smaller">The original approach normalized <span class="highlight">after</span> adding the residual connection.</p>
                
                <div class="two-col">
                    <div>
                        <svg class="viz-svg" viewBox="0 0 400 500">
                            <defs><marker id="arrowhead" markerWidth="8" markerHeight="6" refX="0" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#FFF"/></marker></defs>
                            <text x="200" y="30" class="svg-label" fill="var(--c-bert)">BERT-style Post-LN</text>
                            <text x="200" y="70" class="svg-text">Input (x)</text>
                            <path d="M200 80 V 110" class="svg-arrow"/>
                            <path d="M200 115 H 100 V 275 H 200" class="svg-dashed-arrow"/>
                            <rect x="150" y="115" width="100" height="50" class="svg-box" stroke="var(--c-purple)" fill="#3c2a4f"/>
                            <text x="200" y="145" class="svg-text">F(x)</text>
                            <path d="M200 165 V 195" class="svg-arrow"/>
                            <circle cx="200" cy="210" r="12" fill="var(--c-orange)"/>
                            <text x="200" y="215" class="svg-text">+</text>
                            <path d="M200 222 V 252" class="svg-arrow"/>
                            <rect x="125" y="252" width="150" height="50" class="svg-box" stroke="var(--c-red)" fill="#4c2e2e"/>
                            <text x="200" y="282" class="svg-text">LayerNorm</text>
                            <path d="M200 302 V 332" class="svg-arrow"/>
                            <text x="200" y="360" class="svg-text">Output</text>
                            
                            <!-- Variance indicator -->
                            <text x="300" y="220" class="svg-desc" fill="var(--c-red)">High Variance!</text>
                        </svg>
                    </div>
                    <div>
                        <h4>The Equation: <span class="bert-color">`y = LN(x + F(x))`</span></h4>
                        <p class="smaller">Problem: Before normalization, we compute `x + F(x)` which accumulates variance.</p>
                        
                        <h4 class="fragment">Training Symptoms:</h4>
                        <ul class="smaller fragment">
                            <li><span class="highlight">Loss oscillates wildly</span></li>
                            <li><span class="highlight">Gradients explode/vanish</span></li>
                            <li><span class="highlight">Poor pattern learning</span></li>
                            <li><span class="highlight">Requires 40K warmup steps</span></li>
                            <li><span class="highlight">Limited to ~30 layers</span></li>
                        </ul>
                    </div>
                </div>
            </section>

            <section data-section="revolution">
                <h2>GPT-2's Innovation: Pre-LN (Normalizing Before)</h2>
                <p class="smaller">The breakthrough: normalize <span class="highlight">before</span> the function, keeping the residual path clean.</p>
                
                <div class="two-col">
                    <div>
                        <svg class="viz-svg" viewBox="0 0 400 500">
                            <defs><marker id="arrowhead-pre" markerWidth="8" markerHeight="6" refX="0" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#FFF"/></marker></defs>
                            <text x="200" y="30" class="svg-label" fill="var(--c-gpt)">GPT-2 style Pre-LN</text>
                            <text x="200" y="70" class="svg-text">Input (x)</text>
                            <path d="M200 80 V 110" class="svg-arrow"/>
                            <path d="M200 115 H 100 V 315 H 200" class="svg-arrow" stroke="var(--c-green)"/>
                            <rect x="125" y="115" width="150" height="50" class="svg-box" stroke="var(--c-green)" fill="#2e4c44"/>
                            <text x="200" y="145" class="svg-text">LayerNorm</text>
                            <path d="M200 165 V 195" class="svg-arrow"/>
                            <rect x="150" y="195" width="100" height="50" class="svg-box" stroke="var(--c-purple)" fill="#3c2a4f"/>
                            <text x="200" y="225" class="svg-text">F(LN(x))</text>
                            <circle cx="200" cy="330" r="12" fill="var(--c-orange)"/>
                            <text x="200" y="335" class="svg-text">+</text>
                            <path d="M200 342 V 372" class="svg-arrow"/>
                            <text x="200" y="400" class="svg-text">Output</text>
                            
                            <!-- Clean path indicator -->
                            <text x="50" y="280" class="svg-desc" fill="var(--c-green)">Clean Path!</text>
                        </svg>
                    </div>
                    <div>
                        <h4>The Equation: <span class="gpt-color">`y = x + F(LN(x))`</span></h4>
                        <p class="smaller">Solution: The residual path `x` stays untouched, providing a clean gradient highway.</p>
                        
                        <h4 class="fragment">Training Benefits:</h4>
                        <ul class="smaller fragment">
                            <li><span class="highlight">Smooth loss convergence</span></li>
                            <li><span class="highlight">Stable gradients</span></li>
                            <li><span class="highlight">Excellent pattern learning</span></li>
                            <li><span class="highlight">Minimal/no warmup needed</span></li>
                            <li><span class="highlight">Scales to 100+ layers</span></li>
                        </ul>
                    </div>
                </div>
            </section>

            <section data-section="revolution">
                <h2>The Critical Mathematical Difference</h2>
                <p class="smaller">The gradient flow tells the whole story of why Pre-LN was revolutionary.</p>
                
                <div class="two-col">
                    <div>
                        <h4>Pre-LN Gradient Magic</h4>
                        <p class="smaller">The gradient of `y = x + F(LN(x))` with respect to `x` is:</p>
                        <p class="smaller highlight" style="text-align: center; font-size: 1.2em;">`dy/dx = 1 + dF/dx`</p>
                        <p class="smaller">That <span class="highlight">`1`</span> term is revolutionary:</p>
                        <ul class="smaller">
                            <li>Gradients never vanish (always â‰¥ 1)</li>
                            <li>Perfect gradient flow through residual path</li>
                            <li>Training stable at any depth</li>
                        </ul>
                    </div>
                    <div>
                        <svg class="viz-svg" viewBox="0 0 400 400">
                            <defs><marker id="grad-arrowhead" markerWidth="8" markerHeight="6" refX="0" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="var(--c-orange)"/></marker></defs>
                            
                            <text x="100" y="30" class="svg-label" fill="var(--c-red)">Post-LN</text>
                            <text x="300" y="30" class="svg-label" fill="var(--c-green)">Pre-LN</text>
                            
                            <!-- Post-LN unstable gradients -->
                            <text x="100" y="340" class="svg-desc">Layer 1</text>
                            <text x="100" y="260" class="svg-desc">Layer 10</text>
                            <text x="100" y="180" class="svg-desc">Layer 20</text>
                            <text x="100" y="100" class="svg-desc">Layer 30</text>
                            
                            <path d="M100 320 V 80" stroke="var(--c-red)" stroke-width="2" fill="none" class="fragment" data-fragment-index="1"/>
                            <path d="M100 320 V 80" stroke="var(--c-red)" stroke-width="8" opacity="0.8" fill="none" class="fragment" data-fragment-index="2"/>
                            <text x="100" y="60" class="svg-text" fill="var(--c-red)" class="fragment" data-fragment-index="2">EXPLODES!</text>
                            
                            <!-- Pre-LN stable gradients -->
                            <text x="300" y="340" class="svg-desc">Layer 1</text>
                            <text x="300" y="260" class="svg-desc">Layer 50</text>
                            <text x="300" y="180" class="svg-desc">Layer 96</text>
                            <text x="300" y="100" class="svg-desc">Layer 150</text>
                            
                            <path d="M300 320 V 80" stroke="var(--c-green)" stroke-width="4" fill="none"/>
                            <text x="300" y="60" class="svg-text" fill="var(--c-green)">STABLE!</text>
                        </svg>
                    </div>
                </div>
            </section>

            <section data-section="revolution">
                <h2>The Code Change That Changed Everything</h2>
                <p class="smaller">This architectural revolution was literally <span class="highlight">moving 2 lines of code</span>.</p>
                
                <div class="two-col">
                    <div>
                        <h4 class="bert-color">BERT-style (Post-LN)</h4>
                        <pre class="smaller" style="background: #2d2d2d; padding: 15px; border-radius: 8px; border: 2px solid var(--c-bert);">
<code style="color: #f8f8f2;">def transformer_block(x):
    # Attention or MLP
    out = function(x)
    # Add residual
    out = x + out
    # Normalize AFTER addition
    out = layer_norm(out)
    return out</code></pre>
                    </div>
                    <div>
                        <h4 class="gpt-color">GPT-2 style (Pre-LN)</h4>
                        <pre class="smaller" style="background: #2d2d2d; padding: 15px; border-radius: 8px; border: 2px solid var(--c-gpt);">
<code style="color: #f8f8f2;">def transformer_block(x):
    # Normalize BEFORE function
    norm_x = layer_norm(x)
    # Attention or MLP on normalized input
    out = function(norm_x)
    # Add to original (clean path)
    out = x + out
    return out</code></pre>
                    </div>
                </div>
                
                <div class="fragment" style="margin-top: 30px; text-align: center;">
                    <p class="highlight">Moving `layer_norm()` from line 4 to line 2 enabled GPT-3, ChatGPT, and the entire modern LLM era.</p>
                </div>
            </section>

            <!-- PART IV: THE IMPLEMENTATION -->
            <section data-section="implementation">
                <div class="section-progress">Part IV: Implementation</div>
                <h2>LayerNorm: The Full Hardware Stack</h2>
                <p class="smaller">From mathematical concept to optimized silicon: a single token's journey through LayerNorm</p>
                
                <svg class="viz-svg" viewBox="0 0 1000 600">
                    <defs><marker id="arrowhead" markerWidth="8" markerHeight="6" refX="0" refY="3" orient="auto"><polygon points="0 0, 8 3, 0 6" fill="#FFF"/></marker></defs>
                    
                    <text x="500" y="30" class="svg-label" font-size="16">LayerNorm: Hardware to Software Stack</text>
                    
                    <!-- Main Memory -->
                    <rect x="50" y="60" width="900" height="80" fill="var(--c-gray)" stroke="#FFF" stroke-width="2" rx="10"/>
                    <text x="500" y="85" class="svg-label">Main Memory (DDR)</text>
                    <rect x="70" y="100" width="300" height="30" fill="var(--c-blue)" opacity="0.7"/>
                    <text x="220" y="120" class="svg-text">Input Tensor [seq_len Ã— embed_dim]</text>
                    <rect x="400" y="100" width="100" height="30" fill="var(--c-green)" opacity="0.7"/>
                    <text x="450" y="120" class="svg-text">Î³ params</text>
                    <rect x="520" y="100" width="100" height="30" fill="var(--c-green)" opacity="0.7"/>
                    <text x="570" y="120" class="svg-text">Î² params</text>
                    <rect x="650" y="100" width="250" height="30" fill="var(--c-orange)" opacity="0.7"/>
                    <text x="775" y="120" class="svg-text">Output Tensor</text>
                    
                    <!-- L3 Cache -->
                    <path d="M500 140 V 170" class="svg-arrow"/>
                    <rect x="200" y="170" width="600" height="60" fill="#455a64" stroke="var(--c-blue)" stroke-width="2" rx="8"/>
                    <text x="500" y="190" class="svg-label">L3 Cache (32MB, 40-75 cycles)</text>
                    <rect x="220" y="205" width="200" height="20" fill="var(--c-blue)" opacity="0.8"/>
                    <text x="320" y="218" class="svg-text">Active tensor slice</text>
                    <rect x="440" y="205" width="120" height="20" fill="var(--c-green)" opacity="0.8"/>
                    <text x="500" y="218" class="svg-text">Î³ & Î² vectors</text>
                    
                    <!-- CPU Core -->
                    <path d="M500 230 V 260" class="svg-arrow"/>
                    <rect x="150" y="260" width="700" height="280" fill="#546e7a" stroke="var(--c-purple)" stroke-width="2" rx="10"/>
                    <text x="500" y="280" class="svg-label">CPU Core</text>
                    
                    <!-- L2 Cache -->
                    <rect x="170" y="300" width="660" height="50" fill="#607d8b" stroke="var(--c-orange)" stroke-width="1" rx="5"/>
                    <text x="500" y="320" class="svg-text">L2 Cache (1MB, 10-20 cycles)</text>
                    <rect x="200" y="330" width="150" height="15" fill="var(--c-blue)" opacity="0.9"/>
                    <text x="275" y="342" class="svg-text">Cache lines (64B)</text>
                    
                    <!-- L1 Cache -->
                    <rect x="170" y="370" width="660" height="50" fill="#78909c" stroke="var(--c-green)" stroke-width="1" rx="5"/>
                    <text x="500" y="390" class="svg-text">L1 Cache (32KB, 1-2 cycles)</text>
                    <rect x="200" y="400" width="100" height="15" fill="var(--c-blue)"/>
                    <text x="250" y="412" class="svg-text">16 floats</text>
                    
                    <!-- AVX Registers -->
                    <rect x="300" y="450" width="400" height="80" fill="#37474f" stroke="var(--c-red)" stroke-width="2" rx="8"/>
                    <text x="500" y="470" class="svg-label">AVX-512 Registers</text>
                    <rect x="320" y="485" width="80" height="15" fill="var(--c-red)" opacity="0.8"/>
                    <text x="360" y="497" class="svg-text">zmm0</text>
                    <rect x="420" y="485" width="80" height="15" fill="var(--c-red)" opacity="0.8"/>
                    <text x="460" y="497" class="svg-text">zmm1</text>
                    <rect x="520" y="485" width="80" height="15" fill="var(--c-red)" opacity="0.8"/>
                    <text x="560" y="497" class="svg-text">zmm2</text>
                    <rect x="620" y="485" width="80" height="15" fill="var(--c-red)" opacity="0.8"/>
                    <text x="660" y="497" class="svg-text">zmm3</text>
                    <text x="500" y="520" class="svg-desc">16 Ã— float32 per register, 4-way unrolled</text>
                </svg>
            </section>

            <section data-section="implementation">
                <h2>Memory Layout: The Foundation of Performance</h2>
                <p class="smaller">Contiguous memory layout ensures cache-friendly access patterns and optimal SIMD utilization.</p>
                
                <svg class="viz-svg" viewBox="0 0 800 400">
                    <text x="400" y="30" class="svg-label">Token-wise LayerNorm Memory Pattern</text>
                    
                    <!-- Memory layout -->
                    <rect x="50" y="80" width="700" height="60" fill="var(--c-bg)" stroke="var(--c-blue)" stroke-width="2" rx="5"/>
                    <text x="400" y="100" class="svg-text">Contiguous Memory: [batch_size Ã— seq_len Ã— embed_dim]</text>
                    
                    <!-- Token layout -->
                    <text x="400" y="160" class="svg-text">Single Token Processing (embed_dim = 768)</text>
                    
                    <!-- Cache lines -->
                    <rect x="50" y="180" width="160" height="40" fill="var(--c-green)" opacity="0.7" stroke="var(--c-green)" stroke-width="1"/>
                    <text x="130" y="205" class="svg-text">Cache Line 1</text>
                    <text x="130" y="220" class="svg-desc">Elements 0-15</text>
                    
                    <rect x="220" y="180" width="160" height="40" fill="var(--c-green)" opacity="0.7" stroke="var(--c-green)" stroke-width="1"/>
                    <text x="300" y="205" class="svg-text">Cache Line 2</text>
                    <text x="300" y="220" class="svg-desc">Elements 16-31</text>
                    
                    <rect x="390" y="180" width="160" height="40" fill="var(--c-green)" opacity="0.7" stroke="var(--c-green)" stroke-width="1"/>
                    <text x="470" y="205" class="svg-text">Cache Line 3</text>
                    <text x="470" y="220" class="svg-desc">Elements 32-47</text>
                    
                    <text x="600" y="200" class="svg-text">...</text>
                    
                    <!-- SIMD processing -->
                    <path d="M130 240 V 280" class="svg-arrow"/>
                    <path d="M300 240 V 280" class="svg-arrow"/>
                    <path d="M470 240 V 280" class="svg-arrow"/>
                    
                    <rect x="200" y="290" width="400" height="60" fill="var(--c-orange)" opacity="0.8" stroke="var(--c-orange)" stroke-width="2" rx="8"/>
                    <text x="400" y="315" class="svg-label">SIMD Processing (AVX-512)</text>
                    <text x="400" y="335" class="svg-text">16 elements processed per instruction</text>
                    
                    <!-- Performance metrics -->
                    <text x="50" y="380" class="svg-desc">â€¢ Sequential access: ~95% cache hit rate</text>
                    <text x="400" y="380" class="svg-desc">â€¢ SIMD utilization: 16x parallelism</text>
                </svg>
            </section>

            <section data-section="implementation">
                <h2>SIMD Optimization: 4-Way Unrolled Implementation</h2>
                <p class="smaller">Production-level LayerNorm uses loop unrolling and vectorization for maximum throughput.</p>
                
                <div style="text-align: left;">
                    <pre class="smaller" style="background: #2d2d2d; padding: 20px; border-radius: 8px; font-size: 0.6em;">
<code style="color: #f8f8f2;">// High-performance LayerNorm with 4-way SIMD unrolling
void layernorm_avx512_unrolled(float* out, const float* inp, 
                               const float* weight, const float* bias, 
                               int B, int T, int C) {
    const int SIMD_WIDTH = 16;  // AVX-512 processes 16 floats
    const int UNROLL = 4;       // 4-way loop unrolling
    
    for (int b = 0; b < B; b++) {
        for (int t = 0; t < T; t++) {
            const float* x = inp + b * T * C + t * C;
            float* y = out + b * T * C + t * C;
            
            // Pass 1: Compute mean (vectorized)
            __m512 sum_vec = _mm512_setzero_ps();
            for (int i = 0; i < C; i += SIMD_WIDTH * UNROLL) {
                __m512 x0 = _mm512_loadu_ps(&x[i + 0 * SIMD_WIDTH]);
                __m512 x1 = _mm512_loadu_ps(&x[i + 1 * SIMD_WIDTH]);
                __m512 x2 = _mm512_loadu_ps(&x[i + 2 * SIMD_WIDTH]);
                __m512 x3 = _mm512_loadu_ps(&x[i + 3 * SIMD_WIDTH]);
                
                sum_vec = _mm512_add_ps(sum_vec, x0);
                sum_vec = _mm512_add_ps(sum_vec, x1);
                sum_vec = _mm512_add_ps(sum_vec, x2);
                sum_vec = _mm512_add_ps(sum_vec, x3);
            }
            float mean = _mm512_reduce_add_ps(sum_vec) / C;
            
            // Pass 2: Compute variance (vectorized)
            // Pass 3: Normalize and scale (vectorized)
            // ... (similar unrolled pattern)
        }
    }
}</code></pre>
                </div>
                
                <div class="smaller" style="margin-top: 20px;">
                    <p><span class="highlight">Performance gains:</span> 8-12x speedup over naive implementation</p>
                    <p><span class="highlight">Memory bandwidth:</span> ~80% of theoretical peak</p>
                    <p><span class="highlight">Cache efficiency:</span> 90%+ L1 hit rate</p>
                </div>
            </section>

            <!-- PART V: PUTTING IT ALL TOGETHER -->
            <section data-section="conclusion">
                <div class="section-progress">Part V: Complete Picture</div>
                <h2>The Complete LayerNorm Story</h2>
                <p class="smaller">From mathematical necessity to architectural revolution to optimized implementation</p>
                
                <div style="text-align: center;">
                    <svg class="viz-svg" viewBox="0 0 1000 500" style="max-width: 900px;">
                        <!-- Mathematical foundation -->
                        <rect x="50" y="50" width="200" height="100" fill="var(--c-blue)" opacity="0.3" stroke="var(--c-blue)" stroke-width="2" rx="10"/>
                        <text x="150" y="85" class="svg-label" fill="var(--c-blue)">Mathematics</text>
                        <text x="150" y="105" class="svg-desc">Internal covariate shift</text>
                        <text x="150" y="120" class="svg-desc">Distribution control</text>
                        <text x="150" y="135" class="svg-desc">Formula: Î³(x-Î¼)/Ïƒ + Î²</text>
                        
                        <!-- Arrow 1 -->
                        <path d="M270 100 L320 100" stroke="var(--c-orange)" stroke-width="4" marker-end="url(#arrowhead)"/>
                        <text x="295" y="90" class="svg-desc">enables</text>
                        
                        <!-- Architectural breakthrough -->
                        <rect x="340" y="50" width="200" height="100" fill="var(--c-green)" opacity="0.3" stroke="var(--c-green)" stroke-width="2" rx="10"/>
                        <text x="440" y="85" class="svg-label" fill="var(--c-green)">Revolution</text>
                        <text x="440" y="105" class="svg-desc">Post-LN â†’ Pre-LN</text>
                        <text x="440" y="120" class="svg-desc">BERT â†’ GPT-2</text>
                        <text x="440" y="135" class="svg-desc">Modern AI era</text>
                        
                        <!-- Arrow 2 -->
                        <path d="M560 100 L610 100" stroke="var(--c-orange)" stroke-width="4" marker-end="url(#arrowhead)"/>
                        <text x="585" y="90" class="svg-desc">requires</text>
                        
                        <!-- Implementation -->
                        <rect x="630" y="50" width="200" height="100" fill="var(--c-purple)" opacity="0.3" stroke="var(--c-purple)" stroke-width="2" rx="10"/>
                        <text x="730" y="85" class="svg-label" fill="var(--c-purple)">Implementation</text>
                        <text x="730" y="105" class="svg-desc">SIMD optimization</text>
                        <text x="730" y="120" class="svg-desc">Memory layout</text>
                        <text x="730" y="135" class="svg-desc">8-12x speedup</text>
                        
                        <!-- Impact section -->
                        <rect x="200" y="200" width="600" height="120" fill="var(--c-orange)" opacity="0.2" stroke="var(--c-orange)" stroke-width="3" rx="15"/>
                        <text x="500" y="230" class="svg-label" font-size="18" fill="var(--c-orange)">The Complete Impact</text>
                        
                        <text x="220" y="260" class="svg-text">â€¢ Mathematical foundation: Stable training through distribution control</text>
                        <text x="220" y="280" class="svg-text">â€¢ Architectural breakthrough: Pre-LN enabled 100+ layer models</text>
                        <text x="220" y="300" class="svg-text">â€¢ Performance optimization: Production-ready HPC implementation</text>
                        
                        <!-- Timeline at bottom -->
                        <text x="150" y="380" class="svg-desc">2017: Problem identified</text>
                        <text x="400" y="380" class="svg-desc">2019: Architectural solution</text>
                        <text x="650" y="380" class="svg-desc">2020+: Performance optimization</text>
                        
                        <path d="M150 390 L 750 390" stroke="var(--c-orange)" stroke-width="2"/>
                        <circle cx="150" cy="390" r="5" fill="var(--c-blue)"/>
                        <circle cx="440" cy="390" r="5" fill="var(--c-green)"/>
                        <circle cx="730" cy="390" r="5" fill="var(--c-purple)"/>
                        
                        <text x="500" y="450" class="svg-label" font-size="16">LayerNorm: From Concept to Silicon</text>
                    </svg>
                </div>
            </section>

            <section data-section="conclusion">
                <h2>The Lasting Impact</h2>
                <p class="smaller">LayerNorm represents a perfect example of how deep understanding across multiple layers creates transformative technology.</p>
                
                <div class="three-col" style="margin-top: 40px;">
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 50px; color: var(--c-blue);">ðŸ§®</div>
                        <h4>Mathematical Insight</h4>
                        <p class="smaller">Understanding internal covariate shift led to the LayerNorm formula</p>
                    </div>
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 50px; color: var(--c-green);">âš¡</div>
                        <h4>Architectural Innovation</h4>
                        <p class="smaller">Moving 2 lines of code enabled the modern AI revolution</p>
                    </div>
                    <div style="text-align: center; padding: 20px;">
                        <div style="font-size: 50px; color: var(--c-purple);">ðŸš€</div>
                        <h4>Implementation Excellence</h4>
                        <p class="smaller">SIMD optimization makes it production-ready at scale</p>
                    </div>
                </div>
                
                <div class="fragment" style="margin-top: 40px; text-align: center;">
                    <div style="border: 3px solid var(--c-orange); padding: 30px; border-radius: 15px; background: rgba(255, 167, 38, 0.1);">
                        <h3 style="color: var(--c-orange);">The LayerNorm Legacy</h3>
                        <p class="smaller">Without LayerNorm's mathematical foundation, GPT-2's architectural insight, and modern HPC implementation:</p>
                        <p class="highlight">No ChatGPT â€¢ No GPT-4 â€¢ No modern AI revolution</p>
                    </div>
                </div>
            </section>

        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/reveal.js@4.3.1/dist/reveal.js"></script>
    <script>
        Reveal.initialize({
            controls: true,
            progress: true,
            center: true,
            hash: true,
            width: 1600,
            height: 900,
            transition: 'slide',
        });

        // Chart.js visualizations
        function createProblemChart() {
            const ctx = document.getElementById('problemChart');
            if (!ctx) return;
            
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array.from({length: 100}, (_, i) => i),
                    datasets: [{
                        label: 'Early Training',
                        data: Array.from({length: 100}, () => Math.random() * 0.5 + 0.25),
                        borderColor: '#66bb6a',
                        backgroundColor: 'rgba(102, 187, 106, 0.1)',
                        borderWidth: 2
                    }, {
                        label: 'Mid Training', 
                        data: Array.from({length: 100}, () => Math.random() * 2 + 1),
                        borderColor: '#ffa726',
                        backgroundColor: 'rgba(255, 167, 38, 0.1)',
                        borderWidth: 2
                    }, {
                        label: 'Late Training',
                        data: Array.from({length: 100}, () => Math.random() * 4 + 2),
                        borderColor: '#ef5350', 
                        backgroundColor: 'rgba(239, 83, 80, 0.1)',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { position: 'top' },
                        title: { display: true, text: 'Activation Distributions During Training (Internal Covariate Shift)' }
                    },
                    scales: {
                        y: { beginAtZero: true, title: { display: true, text: 'Activation Value' } },
                        x: { title: { display: true, text: 'Feature Dimension' } }
                    }
                }
            });
        }

        function createBeforeAfterCharts() {
            // Before LayerNorm
            const beforeCtx = document.getElementById('beforeChart');
            if (beforeCtx) {
                new Chart(beforeCtx, {
                    type: 'line',
                    data: {
                        labels: Array.from({length: 50}, (_, i) => i),
                        datasets: [{
                            label: 'Chaotic Distribution',
                            data: Array.from({length: 50}, () => Math.random() * 6 - 1),
                            borderColor: '#ef5350',
                            backgroundColor: 'rgba(239, 83, 80, 0.1)',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { min: -3, max: 6 },
                            x: { display: false }
                        }
                    }
                });
            }

            // After LayerNorm  
            const afterCtx = document.getElementById('afterChart');
            if (afterCtx) {
                new Chart(afterCtx, {
                    type: 'line', 
                    data: {
                        labels: Array.from({length: 50}, (_, i) => i),
                        datasets: [{
                            label: 'Normalized Distribution',
                            data: Array.from({length: 50}, () => Math.random() * 2 - 1),
                            borderColor: '#66bb6a',
                            backgroundColor: 'rgba(102, 187, 106, 0.1)', 
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { min: -3, max: 6 },
                            x: { display: false }
                        }
                    }
                });
            }
        }

        // Photo animations for LayerNorm analogy
        function setupPhotoAnimations() {
            const badPhoto = document.getElementById('bad-photo');
            if (badPhoto) {
                gsap.to(badPhoto, {
                    filter: 'sepia(0.6) brightness(0.7) hue-rotate(20deg)',
                    duration: 1.5,
                    yoyo: true,
                    repeat: -1,
                    ease: "power1.inOut"
                });
                
                gsap.to(badPhoto, {
                    filter: 'saturate(2) brightness(1.3) hue-rotate(-10deg)',
                    duration: 1.2,
                    yoyo: true,
                    repeat: -1,
                    ease: "power1.inOut",
                    delay: 0.7
                });
            }
        }

        function setupInteractiveStyling() {
            const gammaSlider = document.getElementById('gamma');
            const betaBrightnessSlider = document.getElementById('beta-brightness');
            const betaTintSlider = document.getElementById('beta-tint');
            const stylizedPhoto = document.getElementById('stylized-photo');

            if (!gammaSlider || !stylizedPhoto) return;

            function updateStyle() {
                const gamma = gammaSlider.value / 100;
                const brightness = betaBrightnessSlider.value / 100;
                const tint = betaTintSlider.value;

                gsap.set(stylizedPhoto, {
                    filter: `contrast(${gamma}) brightness(${brightness}) sepia(${tint}%)`
                });
            }

            gammaSlider.addEventListener('input', updateStyle);
            betaBrightnessSlider.addEventListener('input', updateStyle);
            betaTintSlider.addEventListener('input', updateStyle);
            
            updateStyle();
        }

        // Initialize everything when reveal.js is ready
        Reveal.on('ready', event => {
            createProblemChart();
            createBeforeAfterCharts();
            setupPhotoAnimations();
            setupInteractiveStyling();
        });

        // Section progress tracking
        Reveal.on('slidechanged', event => {
            const section = event.currentSlide.dataset.section;
            const progressElements = document.querySelectorAll('.section-progress');
            
            const sectionNames = {
                'intro': 'Part I: Foundation',
                'math': 'Part II: Mathematics', 
                'revolution': 'Part III: Revolution',
                'implementation': 'Part IV: Implementation',
                'conclusion': 'Part V: Complete Picture'
            };
            
            progressElements.forEach(el => {
                if (section && sectionNames[section]) {
                    el.textContent = sectionNames[section];
                }
            });
        });
    </script>
</body>
</html>
