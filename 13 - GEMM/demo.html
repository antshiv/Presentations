<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">

  <title>LLM Advanced Memory Technique</title>

  <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
  <meta name="author" content="Hakim El Hattab">

  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="../reveal.js/dist/reset.css">
  <link rel="stylesheet" href="../reveal.js/dist/reveal.css">
  <link rel="stylesheet" href="../reveal.js/dist/theme/black.css" id="theme">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="../reveal.js/plugin/highlight/monokai.css">
  <link rel="stylesheet" href="../css/styles.css">
  <style>
    /* Custom styles for better readability and aesthetics */
    .reveal {
      font-family: 'Inter', sans-serif;
    }

    .reveal h1,
    .reveal h2,
    .reveal h3,
    .reveal h4,
    .reveal h5,
    .reveal h6 {
      text-transform: none;
      /* Prevent uppercase transformation */
      font-weight: 700;
    }

    .reveal section img {
      margin: 15px 0px;
      background: rgba(255, 255, 255, 0.12);
      border: 4px solid #eee;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.15);
    }

    .reveal .slides section .fragment {
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.8s ease-in-out;
    }

    .reveal .slides section .fragment.visible {
      opacity: 1;
      visibility: visible;
    }

    .reveal pre {
      width: 90%;
      margin: 20px auto;
      font-size: 0.7em;
      line-height: 1.2;
    }

    .reveal code {
      font-family: 'Fira Code', monospace;
    }

    .reveal .r-stack {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100%;
    }

    .matrix-svg {
      width: 100%;
      max-width: 600px;
      height: auto;
      margin: 20px auto;
      display: block;
    }

    .kernel-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 20px;
      margin-top: 30px;
    }

    .kernel-item {
      background: rgba(255, 255, 255, 0.05);
      padding: 20px;
      border-radius: 10px;
      text-align: left;
    }

    .kernel-item h3 {
      color: #42affa;
      margin-bottom: 10px;
    }

    .kernel-item ul {
      list-style-type: disc;
      margin-left: 20px;
    }

    .kernel-item li {
      margin-bottom: 5px;
    }

    .r-stack {
      font-size: 18px;
    }

           .matrix-svg {
            width: 100%;
            max-width: 600px;
            height: auto;
            margin: 20px auto;
            display: block;
        }
        .kernel-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 20px;
            margin-top: 30px;
        }
        .kernel-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            text-align: left;
        }
        .kernel-item h3 {
            color: #42affa;
            margin-bottom: 10px;
        }
        .kernel-item ul {
            list-style-type: disc;
            margin-left: 20px;
        }
        .kernel-item li {
            margin-bottom: 5px;
        }
        .benchmark-table {
            width: 90%;
            margin: 20px auto;
            border-collapse: collapse;
            font-size: 0.8em;
        }
        .benchmark-table th, .benchmark-table td {
            border: 1px solid #555;
            padding: 8px;
            text-align: center;
        }
        .benchmark-table th {
            background-color: #333;
            color: #eee;
        }
        .benchmark-table tr:nth-child(even) {
            background-color: #222;
        }
        .recommendation {
            margin-top: 30px;
            font-size: 0.9em;
            color: #42affa;
        }

        /* Styles for the Pipe Analogy SVG */
        .analogy-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }
        .analogy-stage {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
            width: 90%;
            max-width: 800px;
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
        }
        .analogy-stage svg {
            flex-shrink: 0;
            margin-right: 20px;
        }
        .analogy-text {
            text-align: left;
            font-size: 0.75em;
        }
        .analogy-text h4 {
            color: #42affa;
            margin-bottom: 5px;
        }
        .analogy-text p {
            margin-bottom: 5px;
        }

        /* SVG specific styles for analogy */
        .pipe { fill: #555; }
        .water { fill: #00BFFF; }
        .bucket { fill: #777; stroke: #FFF; stroke-width: 2; }
        .clog { fill: #FF4500; }
        .arrow { fill: none; stroke: #00BFFF; stroke-width: 3; marker-end: url(#arrowhead); }
        .small-pipe { fill: #444; }
        .wide-pipe { fill: #777; }
        .clean-pipe { fill: #999; }
        .multiple-pipes .pipe { fill: #666; }
        .multiple-pipes .bucket { fill: #888; }
        .label-text { font-family: 'Inter', sans-serif; font-size: 12px; fill: #FFF; }

        /* Memory Layout SVG styles */
        .mem-matrix-cell {
            fill: #333;
            stroke: #666;
            stroke-width: 0.5;
        }
        .mem-matrix-header-fill {
            fill: #42affa;
        }
        .mem-matrix-header-text {
            fill: #FFF;
            font-size: 10px;
        }
        .mem-matrix-highlight {
            fill: #00BFFF;
        }
        .mem-matrix-text {
            fill: #FFF;
            font-size: 10px;
        }
        .mem-arrow {
            stroke: #FFC107;
            stroke-width: 2;
            marker-end: url(#mem-arrowhead);
        }
        .mem-label {
            fill: #FFF;
            font-size: 14px;
        }

        /* DNA of AI SVG styles */
        .dna-matrix-rect { fill: #333; stroke: #666; stroke-width: 1; }
        .dna-matrix-text { fill: #FFF; font-size: 10px; text-anchor: middle; }
        .dna-arrow { stroke: #FFF; stroke-width: 2; marker-end: url(#dna-arrowhead); }
        .dna-op-label { fill: #FFF; font-size: 12px; text-anchor: middle; }
        .dna-highlight-rect { fill: #4CAF50; opacity: 0.7; }
        .dna-highlight-text { fill: #FFF; font-size: 10px; text-anchor: middle; }
        .dna-qkv-color-q { fill: #FFC107; }
        .dna-qkv-color-k { fill: #2196F3; }
        .dna-qkv-color-v { fill: #E91E63; }
        .dna-qkv-text { fill: #FFF; font-size: 10px; text-anchor: middle; }

                /* Styles for the Combined Benchmark/Analogy Slide */
        .combined-benchmark-slide {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            height: 100%;
            padding: 20px;
        }
        .analogy-column {
            flex: 0 0 30%; /* Fixed width for analogy column */
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            align-items: center;
            height: 90%;
            padding-right: 20px;
        }
        .analogy-mini-stage {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 10px;
            width: 100%;
        }
        .analogy-mini-stage svg {
            width: 80px; /* Smaller SVG size */
            height: 40px;
            margin-bottom: 5px;
        }
        .analogy-mini-stage p {
            font-size: 0.6em;
            text-align: center;
            line-height: 1.2;
        }
        .chart-column {
            flex: 1; /* Takes remaining space */
            height: 90%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative; /* For GSAP animation */
        }
        .chart-container {
            width: 95%;
            height: 45%; /* Adjust height for two charts */
            margin-bottom: 10px;
            position: relative;
        }
        .chart-container canvas {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 10px;
        }
        .chart-title {
            font-size: 1.2em;
            margin-bottom: 10px;
            color: #42affa;
        }
  </style>
</head>

<body>

  <div class="reveal">



    <!-- Any section element inside of this container is displayed as a slide -->
    <div class="slides">
            <!-- Title Slide -->
                  <section>
                <h1>CPU-Optimized LLM Runtime</h1>
                <h2>The DNA of AI: Understanding GEMM Kernels</h2>
                <p><small>A Deep Dive into High-Performance Matrix Multiplication</small></p>
            </section>
      <!-- What is GEMM? -->
      <section>
        <h2>What is GEMM?</h2>
        <h3>General Matrix Multiply: The "Atom" of Modern AI</h3>
        <div class="r-stack" style="font-size:24px;">
          <p class="fragment">At its core, GEMM is a fundamental operation: $C = \alpha A B + \beta C$.</p>
          <p class="fragment">It's the workhorse behind almost every operation in neural networks:</p>
          <ul class="fragment">
            <li><strong>Linear Layers:</strong> The primary component of Transformer models.</li>
            <li><strong>Attention Mechanisms:</strong> Calculating Query-Key-Value projections.</li>
            <li><strong>Convolutional Layers:</strong> Often reformulated as GEMM.</li>
          </ul>
          <p class="fragment"><strong>Why is it the "DNA" or "Atom"?</strong></p>
          <p class="fragment">Because optimizing GEMM means optimizing the very foundation of AI inference and training,
            leading to massive performance gains.</p>

          <!-- SVG Infographic for Matrix Multiplication -->
          <svg class="matrix-svg fragment" viewBox="0 0 600 200" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <linearGradient id="grad1" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" style="stop-color:#4CAF50;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#8BC34A;stop-opacity:1" />
              </linearGradient>
              <linearGradient id="grad2" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" style="stop-color:#2196F3;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#03A9F4;stop-opacity:1" />
              </linearGradient>
              <linearGradient id="grad3" x1="0%" y1="0%" x2="100%" y2="0%">
                <stop offset="0%" style="stop-color:#FFC107;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#FFEB3B;stop-opacity:1" />
              </linearGradient>
            </defs>

            <!-- Matrix A -->
            <rect x="50" y="50" width="100" height="100" fill="url(#grad1)" rx="10" ry="10" />
            <text x="100" y="100" font-family="Arial" font-size="24" fill="#FFF" text-anchor="middle"
              alignment-baseline="middle">A</text>
            <text x="100" y="170" font-family="Arial" font-size="18" fill="#FFF" text-anchor="middle">($M \times
              K$)</text>

            <!-- Multiplication Sign -->
            <text x="180" y="100" font-family="Arial" font-size="36" fill="#FFF" text-anchor="middle"
              alignment-baseline="middle">×</text>

            <!-- Matrix B -->
            <rect x="230" y="50" width="100" height="100" fill="url(#grad2)" rx="10" ry="10" />
            <text x="280" y="100" font-family="Arial" font-size="24" fill="#FFF" text-anchor="middle"
              alignment-baseline="middle">B</text>
            <text x="280" y="170" font-family="Arial" font-size="18" fill="#FFF" text-anchor="middle">($K \times
              N$)</text>

            <!-- Equals Sign -->
            <text x="360" y="100" font-family="Arial" font-size="36" fill="#FFF" text-anchor="middle"
              alignment-baseline="middle">=</text>

            <!-- Matrix C -->
            <rect x="410" y="50" width="100" height="100" fill="url(#grad3)" rx="10" ry="10" />
            <text x="460" y="100" font-family="Arial" font-size="24" fill="#FFF" text-anchor="middle"
              alignment-baseline="middle">C</text>
            <text x="460" y="170" font-family="Arial" font-size="18" fill="#FFF" text-anchor="middle">($M \times
              N$)</text>

            <!-- AI Icon -->
            <g transform="translate(530, 20)">
              <circle cx="30" cy="30" r="25" fill="#E0F7FA" stroke="#00BCD4" stroke-width="2" />
              <path d="M20 20 L40 20 L40 40 L20 40 Z" fill="#00BCD4" />
              <circle cx="25" cy="25" r="3" fill="#FFF" />
              <circle cx="35" cy="25" r="3" fill="#FFF" />
              <path d="M25 35 Q30 38 35 35" stroke="#00BCD4" stroke-width="2" fill="none" />
              <text x="30" y="65" font-family="Arial" font-size="14" fill="#FFF" text-anchor="middle">AI</text>
            </g>
          </svg>
        </div>
      </section>
            <!-- Matrix Multiplication: The DNA of AI -->
            <section>
                <h4>Matrix Multiplication: The DNA of AI</h4>
                <h5>The Fundamental Pattern: $y = wx + b$</h5>
                <div class="r-stack">
                <p class="fragment">Every neural computation starts from this basic linear transformation.</p>

                <svg width="100%" height="450" viewBox="0 0 900 450" class="fragment">
                    <defs>
                        <marker id="dna-arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                            <polygon points="0 0, 10 3.5, 0 7" fill="#FFF" />
                        </marker>
                    </defs>

                    <!-- Fundamental Pattern -->
                    <rect x="300" y="20" width="300" height="50" rx="10" ry="10" fill="#222" stroke="#4CAF50" stroke-width="2"/>
                    <text x="450" y="50" class="dna-op-label" font-size="18">The Fundamental Pattern: $y = wx + b$</text>

                    <!-- 1. Linear Layers (Feed-Forward) -->
                    <text x="150" y="120" class="dna-op-label">1. Linear Layers (Feed-Forward)</text>
                    <!-- Input x -->
                    <rect x="50" y="150" width="40" height="80" class="dna-matrix-rect" fill="#00BCD4"/>
                    <text x="70" y="195" class="dna-matrix-text">x</text>
                    <text x="70" y="245" class="dna-matrix-text">Input</text>
                    <text x="70" y="260" class="dna-matrix-text">($D_{in} \times 1$)</text>
                    <path d="M90 190 H120" class="dna-arrow"/>
                    <text x="105" y="185" class="dna-op-label" font-size="16">×</text>

                    <!-- Weights w -->
                    <rect x="130" y="150" width="80" height="80" class="dna-matrix-rect" fill="#E91E63"/>
                    <text x="170" y="195" class="dna-matrix-text">w</text>
                    <text x="170" y="245" class="dna-matrix-text">Weights</text>
                    <text x="170" y="260" class="dna-matrix-text">($D_{out} \times D_{in}$)</text>
                    <path d="M210 190 H240" class="dna-arrow"/>
                    <text x="225" y="185" class="dna-op-label" font-size="16">+</text>

                    <!-- Bias b -->
                    <rect x="250" y="150" width="40" height="80" class="dna-matrix-rect" fill="#FFC107"/>
                    <text x="270" y="195" class="dna-matrix-text">b</text>
                    <text x="270" y="245" class="dna-matrix-text">Bias</text>
                    <text x="270" y="260" class="dna-matrix-text">($D_{out} \times 1$)</text>
                    <path d="M290 190 H320" class="dna-arrow"/>
                    <text x="305" y="185" class="dna-op-label" font-size="16">=</text>

                    <!-- Output y -->
                    <rect x="330" y="150" width="40" height="80" class="dna-matrix-rect" fill="#9C27B0"/>
                    <text x="350" y="195" class="dna-matrix-text">y</text>
                    <text x="350" y="245" class="dna-matrix-text">Output</text>
                    <text x="350" y="260" class="dna-matrix-text">($D_{out} \times 1$)</text>

                    <!-- 2. Attention: Query x Key x Value -->
                    <text x="650" y="120" class="dna-op-label">2. Attention: Query × Key × Value</text>
                    <!-- Input -->
                    <rect x="450" y="150" width="40" height="80" class="dna-matrix-rect" fill="#00BCD4"/>
                    <text x="470" y="195" class="dna-matrix-text">Input</text>
                    <path d="M490 190 H520" class="dna-arrow"/>

                    <!-- W_qkv -->
                    <rect x="530" y="150" width="80" height="80" class="dna-matrix-rect" fill="#E91E63"/>
                    <text x="570" y="195" class="dna-matrix-text">W_qkv</text>
                    <path d="M610 190 H640" class="dna-arrow"/>

                    <!-- Q, K, V -->
                    <rect x="650" y="150" width="20" height="80" class="dna-matrix-rect dna-qkv-color-q"/>
                    <text x="660" y="195" class="dna-qkv-text">Q</text>
                    <rect x="670" y="150" width="20" height="80" class="dna-matrix-rect dna-qkv-color-k"/>
                    <text x="680" y="195" class="dna-qkv-text">K</text>
                    <rect x="690" y="150" width="20" height="80" class="dna-matrix-rect dna-qkv-color-v"/>
                    <text x="700" y="195" class="dna-qkv-text">V</text>
                    <text x="675" y="245" class="dna-matrix-text">3 x embed_dim</text>

                    <!-- Q x K.T = Scores -->
                    <rect x="650" y="280" width="40" height="40" class="dna-matrix-rect dna-qkv-color-q"/>
                    <text x="670" y="300" class="dna-qkv-text">Q</text>
                    <text x="690" y="300" class="dna-op-label" font-size="16">×</text>
                    <rect x="700" y="280" width="40" height="40" class="dna-matrix-rect dna-qkv-color-k"/>
                    <text x="720" y="300" class="dna-qkv-text">K.T</text>
                    <text x="750" y="300" class="dna-op-label" font-size="16">=</text>
                    <rect x="760" y="280" width="40" height="40" class="dna-matrix-rect" fill="#8BC34A"/>
                    <text x="780" y="300" class="dna-qkv-text">Scores</text>
                    <path d="M805 300 H820" class="dna-arrow"/>
                    <text x="830" y="300" class="dna-op-label" font-size="12">Softmax</text>
                    <path d="M865 300 H880" class="dna-arrow"/>
                    <text x="890" y="300" class="dna-op-label" font-size="16">×</text>
                    <rect x="830" y="330" width="40" height="40" class="dna-matrix-rect dna-qkv-color-v"/>
                    <text x="850" y="350" class="dna-qkv-text">V</text>
                    <path d="M875 350 V310" class="dna-arrow"/>
                    <text x="890" y="350" class="dna-op-label" font-size="16">=</text>
                    <rect x="890" y="330" width="40" height="40" class="dna-matrix-rect" fill="#9C27B0"/>
                    <text x="910" y="350" class="dna-qkv-text">Output</text>


                    <!-- Bottom Summary -->
                    <rect x="50" y="390" width="800" height="150" rx="10" ry="10" fill="#222" stroke="#4CAF50" stroke-width="2"/>
                    <text x="450" y="410" class="dna-op-label" font-size="16">🎉 Every AI Operation = Matrix Multiplication ($wx + b$)</text>
                    <text x="450" y="430" class="dna-op-label" font-size="14">Linear layers, attention, embeddings, projections - all variations of the same fundamental pattern</text>
                    <text x="450" y="445" class="dna-op-label" font-size="14">Optimize matrix multiplication → Optimize all of AI!</text>
                </svg>
                </div>
            </section>

                        <!-- Memory Layout Optimization -->
            <section>
                <h2>Memory Layout: Math vs. Memory for Optimization</h2>
                <h3>Smart Storage = No Transpose Needed</h3>
                <div class="r-stack">
                    <p class="fragment">The mathematical definition of matrix multiplication often implies transposes. However, for performance, we optimize memory layout to avoid these costly runtime operations.</p>

                    <svg width="100%" height="550" viewBox="0 0 900 550" class="fragment">
                        <defs>
                            <marker id="mem-arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                <polygon points="0 0, 10 3.5, 0 7" fill="#FFC107" />
                            </marker>
                        </defs>

                        <!-- Mathematical View (On Paper) -->
                        <text x="450" y="20" class="mem-label" font-size="18">Mathematical View: $A \times B^T = C$ (on paper)</text>

                        <!-- Matrix A (Input) - Conceptual -->
                        <rect x="50" y="60" width="100" height="100" class="dna-matrix-rect" fill="#00BCD4"/>
                        <text x="100" y="115" class="dna-matrix-text">Matrix A (Input)</text>
                        <text x="100" y="130" class="dna-matrix-text">($N_{ctx} \times D_{embed}$)</text>
                        <text x="170" y="115" font-size="24" fill="#FFF">×</text>

                        <!-- Matrix B.T (Weights) - Conceptual -->
                        <rect x="200" y="60" width="100" height="100" class="dna-matrix-rect" fill="#E91E63"/>
                        <text x="250" y="115" class="dna-matrix-text">Matrix B.T (Weights)</text>
                        <text x="250" y="130" class="dna-matrix-text">($D_{embed} \times D_{output}$)</text>
                        <text x="320" y="115" font-size="24" fill="#FFF">=</text>

                        <!-- Matrix C (Output) - Conceptual -->
                        <rect x="350" y="60" width="100" height="100" class="dna-matrix-rect" fill="#9C27B0"/>
                        <text x="400" y="115" class="dna-matrix-text">Matrix C (Output)</text>
                        <text x="400" y="130" class="dna-matrix-text">($N_{ctx} \times D_{output}$)</text>

                        <!-- Problem Box -->
                        <rect x="500" y="60" width="350" height="100" rx="10" ry="10" fill="rgba(255, 69, 0, 0.1)" stroke="#FF4500" stroke-width="2"/>
                        <text x="675" y="85" class="mem-label" font-size="16">Problem:</text>
                        <text x="675" y="105" class="mem-matrix-text" text-anchor="middle">B/T means transpose!</text>
                        <text x="675" y="120" class="mem-matrix-text" text-anchor="middle">Expensive memory access</text>
                        <text x="675" y="135" class="mem-matrix-text" text-anchor="middle">Cache misses galore</text>

                        <!-- Memory Layout View (Smart Storage) -->
                        <text x="450" y="220" class="mem-label" font-size="18">Memory Layout: Smart Storage = No Transpose Needed</text>

                        <!-- Matrix A in Memory (X) -->
                        <text x="100" y="250" class="mem-label" font-size="14">Matrix A in Memory (X)</text>
                        <text x="100" y="265" class="mem-matrix-text">Row-major: token by token</text>
                        <rect x="50" y="280" width="100" height="100" class="mem-matrix-cell" stroke="#00BFFF" stroke-width="2"/>
                        <rect x="50" y="280" width="100" height="20" class="mem-matrix-highlight"/>
                        <text x="100" y="292" class="mem-matrix-text">Token 0</text>
                        <rect x="50" y="300" width="100" height="20" class="mem-matrix-highlight"/>
                        <text x="100" y="312" class="mem-matrix-text">Token 1</text>
                        <text x="100" y="350" class="mem-matrix-text">...</text>
                        <path d="M155 330 H180" class="mem-arrow"/>
                        <text x="100" y="395" class="mem-matrix-text">Sequential memory access ✅</text>

                        <!-- Matrix B in Memory (W.T) -->
                        <text x="350" y="250" class="mem-label" font-size="14">Matrix B in Memory (W.T)</text>
                        <text x="350" y="265" class="mem-matrix-text">Pre-transposed, row-major</text>
                        <rect x="200" y="280" width="200" height="100" class="mem-matrix-cell" stroke="#4CAF50" stroke-width="2"/>
                        <rect x="200" y="280" width="20" height="100" class="mem-matrix-highlight"/>
                        <text x="210" y="330" class="mem-matrix-text" transform="rotate(-90 210 330)">Output Dim 0</text>
                        <rect x="220" y="280" width="20" height="100" class="mem-matrix-highlight"/>
                        <text x="230" y="330" class="mem-matrix-text" transform="rotate(-90 230 330)">Output Dim 1</text>
                        <text x="300" y="330" class="mem-matrix-text">...</text>
                        <rect x="380" y="280" width="20" height="100" class="mem-matrix-highlight"/>
                        <text x="390" y="330" class="mem-matrix-text" transform="rotate(-90 390 330)">Output Dim D-1</text>
                        <path d="M405 330 H430" class="mem-arrow"/>
                        <text x="300" y="395" class="mem-matrix-text">W stored as W.T ✅</text>

                        <!-- Matrix C in Memory (Output) -->
                        <text x="590" y="250" class="mem-label" font-size="14">Matrix C in Memory (Output)</text>
                        <text x="590" y="265" class="mem-matrix-text">Row-major output</text>
                        <rect x="440" y="280" width="100" height="100" class="mem-matrix-cell" stroke="#FFC107" stroke-width="2"/>
                        <rect x="440" y="280" width="100" height="20" class="mem-matrix-highlight"/>
                        <text x="490" y="292" class="mem-matrix-text">Output Token 0</text>
                        <rect x="440" y="300" width="100" height="20" class="mem-matrix-highlight"/>
                        <text x="490" y="312" class="mem-matrix-text">Output Token 1</text>
                        <text x="490" y="350" class="mem-matrix-text">...</text>
                        <text x="590" y="395" class="mem-matrix-text">Cache-friendly layout ✅</text>

                        <!-- Low-Level Optimization Insight -->
                        <rect x="50" y="450" width="800" height="90" rx="10" ry="10" fill="#222" stroke="#4CAF50" stroke-width="2"/>
                        <text x="450" y="470" class="mem-label" font-size="16">Low-Level Optimization Insight: Math $\neq$ Memory Layout</text>
                        <text x="450" y="490" class="mem-matrix-text" font-size="14">Mathematical notation $A \times B^T$ suggests transpose, but smart storage pre-transposes B.</text>
                        <text x="450" y="505" class="mem-matrix-text" font-size="14">Your Token-Parallel kernel achieves 6x speedup by combining: smart layout + cache blocking + core distribution.</text>
                        <text x="450" y="520" class="mem-matrix-text" font-size="14">Memory bandwidth >> Compute Throughput in modern AI workloads.</text>
                    </svg>
                </div>
            </section>
      
      <!-- The Four Kernels -->
      <section>
        <h2>The Four Kernels Developed</h2>
        <p>We've engineered distinct GEMM kernels, each embodying different optimization strategies:</p>
        <div class="kernel-grid" style="font-size: 18px;">
          <div class="kernel-item fragment fade-in-then-semi-out">
            <h3>1. Naive Parallel GEMM</h3>
            <ul>
              <li>Basic triple-loop implementation.</li>
              <li>Parallelized using OpenMP for outer loops.</li>
              <li>Serves as the baseline for performance and accuracy.</li>
            </ul>
          </div>
          <div class="kernel-item fragment fade-in-then-semi-out">
            <h3>2. Simple AVX-512 Parallel GEMM</h3>
            <ul>
              <li>Introduces AVX-512 intrinsics for vectorization.</li>
              <li>Processes 16 floats simultaneously.</li>
              <li>Still relies on OpenMP for thread-level parallelism.</li>
            </ul>
          </div>
          <div class="kernel-item fragment fade-in-then-semi-out">
            <h3>3. Fine-Grained Blocked GEMM</h3>
            <ul>
              <li>Combines AVX-512 with cache blocking (64x64 blocks).</li>
              <li>Aims to improve data locality and cache utilization.</li>
              <li>OpenMP `collapse(3)` for multi-level parallelism.</li>
            </ul>
          </div>
          <div class="kernel-item fragment fade-in-then-semi-out">
            <h3>4. Token-Parallel Orchestration</h3>
            <ul>
              <li>A higher-level strategy, not a direct GEMM kernel.</li>
              <li>Distributes input tokens across multiple cores.</li>
              <li>Each core executes a <strong>serial blocked GEMM</strong> on its local token slice.</li>
              <li>Leverages `gemm_blocked_serial` internally.</li>
            </ul>
          </div>
        </div>
      </section>

      <!-- Optimization Differences (Slide 1) -->
      <section>
        <h2>Optimization Differences: Naive vs. Vectorized</h2>
        <div class="r-stack" style="font-size: 18px;">
          <div style="display: flex; justify-content: space-around; width: 100%;">
            <div style="width: 45%; text-align: left;">
              <h3>Naive Parallel GEMM</h3>
              <pre><code class="c">void gemm_naive_parallel(...) {
    #pragma omp parallel for
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < N; j++) {
            float sum = 0;
            for (int k = 0; k < K; k++) {
                sum += A[i * K + k] * B[j * K + k];
            }
            C[i * N + j] = sum + bias[j];
        }
    }
}</code></pre>
              <ul>
                <li><strong>Concept:</strong> Direct translation of matrix multiplication.</li>
                <li><strong>Parallelism:</strong> Coarse-grained (outer loops) with OpenMP.</li>
                <li><strong>Limitations:</strong> Poor cache utilization, no vectorization.</li>
              </ul>
            </div>
            <div style="width: 45%; text-align: left;">
              <h3>Simple AVX-512 Parallel GEMM</h3>
              <pre><code class="c">void gemm_avx512_parallel(...) {
    #pragma omp parallel for
    for (int i = 0; i < M; i++) {
        for (int j = 0; j < N; j++) {
            __m512 sum_vec = _mm512_setzero_ps();
            for (k = 0; k &lt;= K - 16; k += 16) {
                __m512 a_vec = _mm512_loadu_ps(&A[i * K + k]);
                __m512 b_vec = _mm512_loadu_ps(&B[j * K + k]);
                sum_vec = _mm512_fmadd_ps(a_vec, b_vec, sum_vec);
            }
            float sum = _mm512_reduce_add_ps(sum_vec);
            // ... handle remainder ...
            C[i * N + j] = sum + bias[j];
        }
    }
}</code></pre>
              <ul>
                <li><strong>Concept:</strong> Vectorization using Intel AVX-512 intrinsics.</li>
                <li><strong>Parallelism:</strong> Still OpenMP for outer loops, but inner loop is vectorized.</li>
                <li><strong>Benefit:</strong> Processes 16 floats per instruction, significant speedup.</li>
              </ul>
            </div>
          </div>
        </div>
      </section>

      <!-- Optimization Differences (Slide 2) -->
      <section>
        <h2>Optimization Differences: Blocking & Orchestration</h2>
        <div class="r-stack">
          <div style="display: flex; justify-content: space-around; width: 100%;">
            <div style="width: 45%; text-align: left;">
              <h3>Fine-Grained Blocked GEMM</h3>
              <pre><code class="c">void gemm_fine_grained_parallel(...) {
    const int block_size = 64;
    #pragma omp parallel for collapse(3)
    for (int ii = 0; ii < M; ii += block_size) {
        for (int jj = 0; jj < N; jj += block_size) {
            for (int kk = 0; kk < K; kk += block_size) {
                // ... block processing with AVX-512 ...
                // ... atomic update for C[i*N+j] ...
            }
        }
    }
}</code></pre>
              <ul>
                <li><strong>Concept:</strong> Divide matrices into smaller blocks (e.g., 64x64).</li>
                <li><strong>Benefit:</strong> Improves cache locality by keeping data in faster memory levels.</li>
                <li><strong>Parallelism:</strong> OpenMP `collapse(3)` for parallelizing block iterations.</li>
                <li><strong>Challenge:</strong> Requires careful handling of partial sums and potential race conditions
                  (e.g., `#pragma omp atomic`).</li>
              </ul>
            </div>
            <div style="width: 45%; text-align: left;">
              <h3>Token-Parallel Orchestration</h3>
              <pre><code class="c">if (i == 3) { // Special case in benchmark
    #pragma omp parallel num_threads(M->num_cores)
    {
        int core_id = omp_get_thread_num();
        int token_start = core_id * M->tokens_per_core;
        int num_tokens = ...;
        if (num_tokens > 0) {
            gemm_blocked_serial(A_input + token_start * K, B_weights, bias, C_out + token_start * N, num_tokens, N, K);
        }
    }
}</code></pre>
              <ul>
                <li><strong>Concept:</strong> Distribute the "M" dimension (tokens) across CPU cores.</li>
                <li><strong>Each Core:</strong> Independently computes a slice of the output using
                  `gemm_blocked_serial`.</li>
                <li><strong>Benefit:</strong> Maximizes CPU utilization by assigning distinct, non-overlapping work to
                  each core.</li>
                <li><strong>Note:</strong> `gemm_blocked_serial` itself is a serial, blocked AVX-512 GEMM, designed for
                  single-core efficiency within this orchestration.</li>
              </ul>
            </div>
          </div>
        </div>
      </section>

                  <!-- Pipe and Buckets Analogy -->
            <section>
              <div class="r-stack">
                <h2>Analogy: Water in a Pipe (Caches & Compute)</h2>
                <h3>Visualizing GEMM Optimization Strategies</h3>
                <div class="analogy-container">
                    <div class="analogy-stage fragment fade-in">
                        <svg width="180" height="90" viewBox="0 0 180 90">
                            <rect x="10" y="35" width="160" height="20" class="pipe small-pipe"/>
                            <rect x="0" y="25" width="20" height="40" class="bucket"/>
                            <rect x="160" y="25" width="20" height="40" class="bucket"/>
                            <circle cx="90" cy="45" r="10" class="clog"/>
                            <text x="90" y="50" text-anchor="middle" class="label-text">CLOG</text>
                            <path d="M5 45 H175" class="arrow"/>
                            <text x="90" y="15" text-anchor="middle" class="label-text">Memory Pool</text>
                            <text x="90" y="75" text-anchor="middle" class="label-text">9.73 GFLOPS</text>
                        </svg>
                        <div class="analogy-text">
                            <h4>1. Naive Parallel: Clogged Pipe</h4>
                            <p><strong>Pipe:</strong> Narrow (inefficient compute). <strong>Buckets (Cache):</strong> Small, disorganized. Water (data) flows slowly, gets stuck. Poor throughput. Baseline performance.</p>
                        </div>
                    </div>

                    <div class="analogy-stage fragment fade-in">
                        <svg width="180" height="90" viewBox="0 0 180 90">
                            <rect x="10" y="35" width="160" height="20" class="pipe wide-pipe"/>
                            <rect x="0" y="25" width="20" height="40" class="bucket"/>
                            <rect x="160" y="25" width="20" height="40" class="bucket"/>
                            <circle cx="90" cy="45" r="8" class="clog" fill="#FFA07A"/>
                            <text x="90" y="50" text-anchor="middle" class="label-text">LESS CLOG</text>
                            <path d="M5 45 H175" class="arrow"/>
                            <text x="90" y="15" text-anchor="middle" class="label-text">Memory Pool</text>
                            <text x="90" y="75" text-anchor="middle" class="label-text">11.57 GFLOPS (1.19x)</text>
                        </svg>
                        <div class="analogy-text">
                            <h4>2. Simple AVX-512: Wider Pipe, Still Some Clogging</h4>
                            <p><strong>Pipe:</strong> Wider (vectorized compute with AVX-512) allowing more water per push. But buckets are still disorganized, causing some data bottlenecks. Moderate speedup.</p>
                        </div>
                    </div>

                    <div class="analogy-stage fragment fade-in">
                        <svg width="180" height="90" viewBox="0 0 180 90">
                            <rect x="10" y="35" width="160" height="20" class="pipe clean-pipe"/>
                            <rect x="0" y="25" width="20" height="40" class="bucket"/>
                            <rect x="160" y="25" width="20" height="40" class="bucket"/>
                            <path d="M5 45 H175" class="arrow"/>
                            <rect x="40" y="40" width="20" height="10" fill="#00BFFF" opacity="0.5"/>
                            <rect x="70" y="40" width="20" height="10" fill="#00BFFF" opacity="0.5"/>
                            <rect x="100" y="40" width="20" height="10" fill="#00BFFF" opacity="0.5"/>
                            <text x="90" y="15" text-anchor="middle" class="label-text">Memory Pool</text>
                            <text x="90" y="75" text-anchor="middle" class="label-text">47.09 GFLOPS (4.84x)</text>
                        </svg>
                        <div class="analogy-text">
                            <h4>3. Fine-Grained Blocked: Cleaned Pipe, Organized Buckets</h4>
                            <p><strong>Pipe:</strong> Optimized (AVX-512). <strong>Buckets:</strong> Organized (cache blocking) ensuring water is ready when needed. Flow is much smoother, reducing idle time. Significant speedup.</p>
                        </div>
                    </div>

                    <div class="analogy-stage fragment fade-in">
                        <svg width="180" height="90" viewBox="0 0 180 90" class="multiple-pipes">
                            <rect x="10" y="10" width="160" height="10" class="pipe"/>
                            <rect x="0" y="5" width="10" height="20" class="bucket"/>
                            <rect x="170" y="5" width="10" height="20" class="bucket"/>
                            <path d="M5 15 H175" class="arrow"/>
                            <text x="90" y="25" text-anchor="middle" class="label-text">Core 0 (22 tokens)</text>

                            <rect x="10" y="40" width="160" height="10" class="pipe"/>
                            <rect x="0" y="35" width="10" height="20" class="bucket"/>
                            <rect x="170" y="35" width="10" height="20" class="bucket"/>
                            <path d="M5 45 H175" class="arrow"/>
                            <text x="90" y="55" text-anchor="middle" class="label-text">Core 1 (22 tokens)</text>

                            <rect x="10" y="70" width="160" height="10" class="pipe"/>
                            <rect x="0" y="65" width="10" height="20" class="bucket"/>
                            <rect x="170" y="65" width="10" height="20" class="bucket"/>
                            <path d="M5 75 H175" class="arrow"/>
                            <text x="90" y="85" text-anchor="middle" class="label-text">... (188 cores)</text>
                            <text x="90" y="5" text-anchor="middle" class="label-text">Memory Pool</text>
                            <text x="90" y="95" text-anchor="middle" class="label-text">60.24 GFLOPS (6.19x)</text>
                        </svg>
                        <div class="analogy-text">
                            <h4>4. Token-Parallel Orchestration: Dedicated Pipes & Buckets</h4>
                            <p><strong>Multiple Pipes & Buckets:</strong> Each core gets its own dedicated pipe and organized buckets (L1/L2 cache). Water (tokens) flows in parallel with minimal interference. Maximizes overall throughput. Best performance.</p>
                        </div>
                    </div>
                </div>
                </div>
            </section>

        <div class="slides">
            <!-- Combined Benchmark and Analogy Slide -->
            <section style="font-size:16px;">
                <h2>Real-World Performance: Analogy Meets Data</h2>
                <div class="combined-benchmark-slide">
                    <div class="analogy-column">
                        <div class="analogy-mini-stage">
                            <svg width="100" height="50" viewBox="0 0 180 90">
                                <defs>
                                    <marker id="arrowhead1" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="#00BFFF" />
                                    </marker>
                                </defs>
                                <rect x="10" y="35" width="160" height="20" class="pipe small-pipe"/>
                                <rect x="0" y="25" width="20" height="40" class="bucket"/>
                                <rect x="160" y="25" width="20" height="40" class="bucket"/>
                                <circle cx="90" cy="45" r="10" class="clog"/>
                                <text x="90" y="50" text-anchor="middle" class="label-text">CLOG</text>
                                <path d="M5 45 H175" class="arrow" marker-end="url(#arrowhead1)"/>
                                <text x="90" y="15" text-anchor="middle" class="label-text">Naive</text>
                            </svg>
                            <p>Naive Parallel</p>
                        </div>
                        
                        <div class="analogy-mini-stage">
                            <svg width="100" height="50" viewBox="0 0 180 90">
                                <defs>
                                    <marker id="arrowhead2" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="#00BFFF" />
                                    </marker>
                                </defs>
                                <rect x="10" y="35" width="160" height="20" class="pipe wide-pipe"/>
                                <rect x="0" y="25" width="20" height="40" class="bucket"/>
                                <rect x="160" y="25" width="20" height="40" class="bucket"/>
                                <circle cx="90" cy="45" r="8" class="clog" fill="#FFA07A"/>
                                <text x="90" y="50" text-anchor="middle" class="label-text">LESS CLOG</text>
                                <path d="M5 45 H175" class="arrow" marker-end="url(#arrowhead2)"/>
                                <text x="90" y="15" text-anchor="middle" class="label-text">AVX-512</text>
                            </svg>
                            <p>Simple AVX-512</p>
                        </div>
                        
                        <div class="analogy-mini-stage">
                            <svg width="100" height="50" viewBox="0 0 180 90">
                                <defs>
                                    <marker id="arrowhead3" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="#00BFFF" />
                                    </marker>
                                </defs>
                                <rect x="10" y="35" width="160" height="20" class="pipe clean-pipe"/>
                                <rect x="0" y="25" width="20" height="40" class="bucket"/>
                                <rect x="160" y="25" width="20" height="40" class="bucket"/>
                                <path d="M5 45 H175" class="arrow" marker-end="url(#arrowhead3)"/>
                                <rect x="40" y="40" width="20" height="10" fill="#00BFFF" opacity="0.5"/>
                                <rect x="70" y="40" width="20" height="10" fill="#00BFFF" opacity="0.5"/>
                                <rect x="100" y="40" width="20" height="10" fill="#00BFFF" opacity="0.5"/>
                                <text x="90" y="15" text-anchor="middle" class="label-text">Blocked</text>
                            </svg>
                            <p>Fine-Grained Blocked</p>
                        </div>
                        
                        <div class="analogy-mini-stage">
                            <svg width="100" height="50" viewBox="0 0 180 90" class="multiple-pipes">
                                <defs>
                                    <marker id="arrowhead4" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="#00BFFF" />
                                    </marker>
                                </defs>
                                <rect x="10" y="15" width="160" height="8" class="pipe"/>
                                <rect x="0" y="10" width="10" height="18" class="bucket"/>
                                <rect x="170" y="10" width="10" height="18" class="bucket"/>
                                <path d="M5 19 H175" class="arrow" marker-end="url(#arrowhead4)"/>
                                
                                <rect x="10" y="35" width="160" height="8" class="pipe"/>
                                <rect x="0" y="30" width="10" height="18" class="bucket"/>
                                <rect x="170" y="30" width="10" height="18" class="bucket"/>
                                <path d="M5 39 H175" class="arrow" marker-end="url(#arrowhead4)"/>
                                
                                <rect x="10" y="55" width="160" height="8" class="pipe"/>
                                <rect x="0" y="50" width="10" height="18" class="bucket"/>
                                <rect x="170" y="50" width="10" height="18" class="bucket"/>
                                <path d="M5 59 H175" class="arrow" marker-end="url(#arrowhead4)"/>
                                
                                <text x="90" y="10" text-anchor="middle" class="label-text">Token-Parallel</text>
                                <text x="90" y="80" text-anchor="middle" class="label-text">...</text>
                            </svg>
                            <p>Token-Parallel Orchestration</p>
                        </div>
                    </div>

                    <div class="chart-column">
                        <div class="chart-container">
                            <h3 class="chart-title">MLP GEMM Performance (GFLOPS)</h3>
                            <canvas id="mlpGflopsChart"></canvas>
                        </div>
                        <div class="chart-container">
                            <h3 class="chart-title">QKV GEMM Performance (GFLOPS)</h3>
                            <canvas id="qkvGflopsChart"></canvas>
                        </div>
                    </div>
                </div>
            </section>


      <!-- Environment Context -->
      <section>
        <h2>Execution Environment Context</h2>
        <div class="r-stack">
          <p class="fragment">The benchmarks were run on a virtualized CPU environment:</p>
          <ul class="fragment">
            <li><strong>CPU Model:</strong> Intel(R) Xeon(R) Platinum 8468V</li>
            <li><strong>Logical Cores:</strong> 192 (96 physical cores with 2 threads per core)</li>
            <li><strong>Key CPU Features:</strong> Includes AVX512F, AVX512DQ, AVX512BW, AVX512VL, AVX512_VNNI,
              AMX_BF16, AMX_TILE, AMX_INT8.</li>
            <li><strong>Memory:</strong> 457.81 GiB allocated for the model.</li>
          </ul>
          <p class="fragment"><strong>Important Note:</strong> This environment is likely shared (e.g., Linux on
            Kubernetes/JupyterLabs with other tenants). Therefore, the absolute performance numbers might be influenced
            by system load.</p>
          <p class="fragment"><strong>The primary value of these benchmarks lies in the *relative* performance
              improvements observed between the different optimization strategies.</strong></p>
        </div>
      </section>

      <!-- How Benchmarking Helps -->
      <section>
        <h2>How Benchmarking Guides Kernel Selection</h2>
        <div class="r-stack">
          <p class="fragment">Our comprehensive benchmark is designed to quantify performance and identify the optimal
            kernel for specific operations within the LLM.</p>
          <ul class="fragment">
            <li><strong>Realistic Workloads:</strong> Tests GEMM kernels on shapes typical of LLM layers (e.g., MLP's
              FC1, Attention's QKV projections).</li>
            <li><strong>Dedicated Memory:</strong> Utilizes the model's bump-allocated memory, ensuring realistic memory
              access patterns.</li>
            <li><strong>Accuracy Validation:</strong> Compares each kernel's output against a "golden reference" (Naive
              kernel output) to ensure numerical stability (Max Diff, RMSE).</li>
          </ul>
          <h3 class="fragment">The Process:</h3>
          <ol class="fragment">
            <li><strong>Golden Reference:</strong> Run the Naive kernel on Layer 0 to establish a ground truth output.
            </li>
            <li><strong>Layer-Specific Testing:</strong> Each of the first four layers is used to test a different
              kernel strategy.</li>
            <li><strong>Consistent Inputs:</strong> The same input data, weights, and biases are copied to each layer's
              memory for fair comparison.</li>
            <li><strong>Metrics Capture:</strong> Time (ms), GFLOPS, Max Difference, and RMSE are recorded.</li>
          </ol>
          <p class="fragment"><strong>Outcome:</strong> The benchmark provides clear performance metrics (GFLOPS,
            speedup) for each kernel on different matrix shapes, allowing us to recommend the best-performing kernel for
            each part of the LLM pipeline on a given CPU architecture.</p>
        </div>
      </section>

      <!-- Benchmark Results -->
      <section>
        <h2>Benchmark Results: Real-World Performance</h2>
        <h3>MLP GEMM (FC1 Layer: M=4096, N=32768, K=8192)</h3>
        <div class="r-stack">"
          <table class="benchmark-table fragment fade-in">
            <thead>
              <tr>
                <th>Strategy</th>
                <th>Time (ms)</th>
                <th>GFLOPS</th>
                <th>Speedup (vs. Naive)</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Naive Parallel</td>
                <td>225958.42</td>
                <td>9.73</td>
                <td>1.00x</td>
              </tr>
              <tr>
                <td>Simple AVX-512</td>
                <td>190026.20</td>
                <td>11.57</td>
                <td>1.19x</td>
              </tr>
              <tr>
                <td>Fine-Grained Blocked</td>
                <td>46699.02</td>
                <td>47.09</td>
                <td>4.84x</td>
              </tr>
              <tr>
                <td>Token-Parallel Orchestration</td>
                <td>36506.94</td>
                <td>60.24</td>
                <td>6.19x</td>
              </tr>
            </tbody>
          </table>
          <p class="recommendation fragment fade-in"><strong>Recommendation for MLP:</strong> 'Token-Parallel
            Orchestration' (60.24 GFLOPS)</p>

          <h3 class="fragment fade-in">QKV GEMM (Attention Layer: M=4096, N=24576, K=8192)</h3>
          <table class="benchmark-table fragment fade-in">
            <thead>
              <tr>
                <th>Strategy</th>
                <th>Time (ms)</th>
                <th>GFLOPS</th>
                <th>Speedup (vs. Naive)</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Naive Parallel</td>
                <td>158063.97</td>
                <td>10.43</td>
                <td>1.00x</td>
              </tr>
              <tr>
                <td>Simple AVX-512</td>
                <td>136269.97</td>
                <td>12.10</td>
                <td>1.16x</td>
              </tr>
              <tr>
                <td>Fine-Grained Blocked</td>
                <td>34986.01</td>
                <td>47.14</td>
                <td>4.52x</td>
              </tr>
              <tr>
                <td>Token-Parallel Orchestration</td>
                <td>25129.17</td>
                <td>65.63</td>
                <td>6.29x</td>
              </tr>
            </tbody>
          </table>
          <p class="recommendation fragment fade-in"><strong>Recommendation for QKV:</strong> 'Token-Parallel
            Orchestration' (65.63 GFLOPS)</p>
        </div>
      </section>

      <!-- Conclusion -->
      <section>
        <h2>Conclusion</h2>
        <div class="r-stack" style="font-size: 28px;">
          <p>Optimizing GEMM is paramount for high-performance LLM runtimes.</p>
          <p class="fragment">By systematically developing and benchmarking diverse kernels, from basic parallel to
            advanced vectorized and blocked approaches, we can precisely identify and utilize the most efficient
            computational strategies for different parts of the model.</p>
          <p class="fragment">This iterative process of design, implementation, and rigorous benchmarking is key to
            unlocking the full potential of modern CPU architectures for AI.</p>
          <p class="fragment">Thank you!</p>
          <p class="fragment" style="font-size: 0.6em; margin-top: 50px;">
            <em>Note: The C code for the LLM runtime and benchmarks is a separate executable. It needs to be compiled
              with a C compiler (e.g., GCC) and run in a suitable environment (e.g., Linux terminal) to execute the
              performance tests. This presentation is for demonstration and visualization purposes.</em>
          </p>
        </div>
      </section>

    </div>
  </div>

  <script src="../reveal.js/dist/reveal.js"></script>
  <script src="../reveal.js/plugin/zoom/zoom.js"></script>
  <script src="../reveal.js/plugin/notes/notes.js"></script>
  <script src="../reveal.js/plugin/search/search.js"></script>
  <script src="../reveal.js/plugin/markdown/markdown.js"></script>
  <script src="../reveal.js/plugin/highlight/highlight.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/plugin/math/math.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/DrawSVGPlugin.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/MotionPathHelper.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/MotionPathPlugin.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/MorphSVGPlugin.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/Physics2DPlugin.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/SplitText.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/TextPlugin.min.js"></script>

  <!-- RoughEase, ExpoScaleEase and SlowMo are all included in the EasePack file -->
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/EasePack.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.13.0/dist/CustomEase.min.js"></script>
  <script src="../js/script.js">	</script>
  <script>
        // Data for charts
        const mlpData = {
            labels: ['Naive Parallel', 'Simple AVX-512', 'Fine-Grained Blocked', 'Token-Parallel Orchestration'],
            datasets: [{
                label: 'GFLOPS',
                data: [9.73, 11.57, 47.09, 60.24],
                backgroundColor: [
                    'rgba(255, 99, 132, 0.7)',
                    'rgba(255, 205, 86, 0.7)',
                    'rgba(75, 192, 192, 0.7)',
                    'rgba(153, 102, 255, 0.7)'
                ],
                borderColor: [
                    'rgb(255, 99, 132)',
                    'rgb(255, 205, 86)',
                    'rgb(75, 192, 192)',
                    'rgb(153, 102, 255)'
                ],
                borderWidth: 1
            }]
        };

        const qkvData = {
            labels: ['Naive Parallel', 'Simple AVX-512', 'Fine-Grained Blocked', 'Token-Parallel Orchestration'],
            datasets: [{
                label: 'GFLOPS',
                data: [10.43, 12.10, 47.14, 65.63],
                backgroundColor: [
                    'rgba(255, 99, 132, 0.7)',
                    'rgba(255, 205, 86, 0.7)',
                    'rgba(75, 192, 192, 0.7)',
                    'rgba(153, 102, 255, 0.7)'
                ],
                borderColor: [
                    'rgb(255, 99, 132)',
                    'rgb(255, 205, 86)',
                    'rgb(75, 192, 192)',
                    'rgb(153, 102, 255)'
                ],
                borderWidth: 1
            }]
        };

        // Chart.js options
        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'y', // Make it a horizontal bar chart
            plugins: {
                legend: {
                    display: false,
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return context.dataset.label + ': ' + context.parsed.x.toFixed(2) + ' GFLOPS';
                        }
                    }
                }
            },
            scales: {
                x: {
                    beginAtZero: true,
                    title: {
                        display: true,
                        text: 'GFLOPS',
                        color: '#eee'
                    },
                    ticks: {
                        color: '#eee'
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                },
                y: {
                    ticks: {
                        color: '#eee'
                    },
                    grid: {
                        color: 'rgba(255, 255, 255, 0.1)'
                    }
                }
            },
            animation: {
                duration: 1500, // Animation duration
                easing: 'easeOutQuart', // Easing function
                delay: (context) => {
                    let delay = 0;
                    if (context.type === 'data' && context.mode === 'default') {
                        delay = context.dataIndex * 150; // Stagger animation
                    }
                    return delay;
                }
            }
        };

        // Initialize Reveal.js
        // Moved inside window.onload to ensure Reveal is defined
        // Ensure Reveal.js and its plugins are loaded before initializing
        document.addEventListener('DOMContentLoaded', function() {
            Reveal.initialize({
                controls: true,
                progress: true,
                center: true,
                hash: true,
                transition: 'slide', // none/fade/slide/convex/concave/zoom
                plugins: [ RevealHighlight, RevealMarkdown, RevealNotes, RevealMath.KaTeX ]
            });

            // Event listener for slide changes to render charts
            Reveal.on('slidechanged', event => {
                if (event.currentSlide.querySelector('#mlpGflopsChart')) {
                    // Ensure charts are only created once
                    if (!window.mlpChart) {
                        const mlpCtx = document.getElementById('mlpGflopsChart').getContext('2d');
                        window.mlpChart = new Chart(mlpCtx, {
                            type: 'bar',
                            data: mlpData,
                            options: chartOptions
                        });
                        gsap.fromTo("#mlpGflopsChart", { opacity: 0, scale: 0.8 }, { opacity: 1, scale: 1, duration: 1, ease: "power2.out" });
                    } else {
                        window.mlpChart.update(); // Update to re-run animations if slide is revisited
                    }

                    if (!window.qkvChart) {
                        const qkvCtx = document.getElementById('qkvGflopsChart').getContext('2d');
                        window.qkvChart = new Chart(qkvCtx, {
                            type: 'bar',
                            data: qkvData,
                            options: chartOptions
                        });
                        gsap.fromTo("#qkvGflopsChart", { opacity: 0, scale: 0.8 }, { opacity: 1, scale: 1, duration: 1, ease: "power2.out", delay: 0.2 });
                    } else {
                        window.qkvChart.update(); // Update to re-run animations if slide is revisited
                    }

                    // GSAP animation for the analogy column
                    gsap.from(".analogy-mini-stage", {
                        opacity: 0,
                        x: -50,
                        stagger: 0.1,
                        duration: 0.8,
                        ease: "power2.out"
                    });
                }
            });
        });
    </script>
</body>

</html>